C51 COMPILER V9.01   CLOCK                                                                 09/14/2023 20:10:43 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE CLOCK
OBJECT MODULE PLACED IN Clock.OBJ
COMPILER INVOKED BY: D:\Software\Keil\C51\BIN\C51.EXE Clock.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <REG51.H>
   2          
   3          #define INTERVAL 1 // 间隔1毫秒
   4          
   5          #define INIT_HOUR 23   // 初始化小时
   6          #define INIT_MINUTE 59 // 初始化分钟
   7          #define INIT_SECOND 58 // 初始化秒
   8          
   9          #define HOURLYCHIMETIMES 3 // 整点响铃次数
  10          #define ALARMCLOCKTIMES 6  // 闹钟响铃次数
  11          
  12          unsigned char hour = INIT_HOUR;     // 初始化小时
  13          unsigned char minute = INIT_MINUTE; // 初始化分钟
  14          unsigned char second = INIT_SECOND; // 初始化秒
  15          
  16          unsigned char alarmHour = 23;   // 闹钟时
  17          unsigned char alarmMinute = 59; // 闹钟分
  18          
  19          enum MODE
  20          {
  21              SHOW,             // 显示模式
  22              SET,              // 设置模式
  23              SET_HOUR,         // 设置时模式
  24              SET_MINUTE,       // 设置分模式
  25              SET_SECOND,       // 设置秒模式
  26              STOPWATCH,        // 秒表模式
  27              STOPWATCH_START,  // 秒表计时模式
  28              STOPWATCH_PAUSE,  // 秒表暂停模式
  29              ALARMCLOCK,       // 闹钟模式
  30              ALARMCLOCK_HOUR,  // 设置闹钟时模式
  31              ALARMCLOCK_MINUTE // 设置闹钟分模式
  32          };
  33          
  34          unsigned char mode = SHOW; // 模式
  35          
  36          unsigned char displayIndex = 0;
  37          unsigned char LED8[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  38          
  39          unsigned int interruptCount = 0; // 中断次数
  40          
  41          bit hourlyChime = 0; // 整点报时功能，1表示开，0表示关
  42          bit alarm = 0;       // 闹钟功能，1表示响，0表示不响
  43          
  44          sbit SEG_DS = P2 ^ 0;   // 74HC595芯片的数据引脚
  45          sbit SEG_SHCP = P2 ^ 1; // 74HC595芯片的控制引脚，上升沿移入数据
  46          sbit SEG_STCP = P2 ^ 2; // 74HC595芯片的控制引脚，上升沿更新数据
  47          
  48          sbit Chime = P2 ^ 3; // 蜂鸣器
  49          
  50          unsigned char code Seg_Data[] = {
  51              // 共阳数码管的编码，并将数据定义在CODE区
  52              0xc0, /*0*/
  53              0xF9, /*1*/
  54              0xA4, /*2*/
  55              0xB0, /*3*/
C51 COMPILER V9.01   CLOCK                                                                 09/14/2023 20:10:43 PAGE 2   

  56              0x99, /*4*/
  57              0x92, /*5*/
  58              0x82, /*6*/
  59              0xF8, /*7*/
  60              0x80, /*8*/
  61              0x90, /*9*/
  62              0x88, /*A*/
  63              0x83, /*b*/
  64              0xC6, /*C*/
  65              0xA1, /*d*/
  66              0x86, /*E*/
  67              0x8E, /*F*/
  68              0xBF, /*-*/
  69              0xFF, /*OFF*/
  70          };
  71          
  72          unsigned char code Seg_Addr[] = {
  73              // 数码管位选编码，控制显示8位中的第几位
  74              0x01,
  75              0x02,
  76              0x04,
  77              0x08,
  78              0x10,
  79              0x20,
  80              0x40,
  81              0x80,
  82              0xFF, // ALL ON
  83              0x00  // OFF
  84          };
  85          
  86          void DisplayOneCharOnAddr(unsigned char, unsigned char Addr);
  87          void SEG_Send595OneByte(unsigned char ucData); // 向74HC595写入一个8位的数据
  88          void SecondIncrease();
  89          
  90          unsigned int checkCount = 0;
  91          unsigned char shortOrLang = 0; // 0表示无效，1表示短按，2表示长按
  92          
  93          bit buttonDown = 0;
  94          bit button = 0;
  95          
  96          sbit P3_2 = P3 ^ 2;
  97          sbit P3_3 = P3 ^ 3;
  98          
  99          // 判断按键是长按还是短按
 100          void Check()
 101          {
 102   1          checkCount++;
 103   1          if (checkCount < 10 / INTERVAL) // 10ms延迟去抖动
 104   1              return;
 105   1      
 106   1          if (checkCount > 1010 / INTERVAL) // 如果大于一秒，为长按
 107   1          {
 108   2              shortOrLang = 2;
 109   2              checkCount = 0;
 110   2              buttonDown = 0;
 111   2          }
 112   1          else
 113   1          {
 114   2              if ((button == 0 && P3_2 == 1) || (button == 1 && P3_3 == 1))
 115   2              {
 116   3                  shortOrLang = 1;
 117   3                  checkCount = 0;
C51 COMPILER V9.01   CLOCK                                                                 09/14/2023 20:10:43 PAGE 3   

 118   3                  buttonDown = 0;
 119   3              }
 120   2          }
 121   1      }
 122          
 123          // 短按处理程序
 124          void ShortPress()
 125          {
 126   1          if (button == 0) // 如果按的是键A
 127   1          {
 128   2              switch (mode)
 129   2              {
 130   3              case SHOW:
 131   3                  mode = SET;
 132   3                  break;
 133   3              case SET:
 134   3                  mode = STOPWATCH;
 135   3                  break;
 136   3              case STOPWATCH:
 137   3                  mode = ALARMCLOCK;
 138   3                  break;
 139   3              case ALARMCLOCK:
 140   3                  mode = SHOW;
 141   3                  break;
 142   3              case SET_HOUR:
 143   3                  mode = SET_MINUTE;
 144   3                  break;
 145   3              case SET_MINUTE:
 146   3                  mode = SET_SECOND;
 147   3                  break;
 148   3              case SET_SECOND:
 149   3                  mode = SET_HOUR;
 150   3                  break;
 151   3              case ALARMCLOCK_HOUR:
 152   3                  mode = ALARMCLOCK_MINUTE;
 153   3                  break;
 154   3              case ALARMCLOCK_MINUTE:
 155   3                  mode = ALARMCLOCK_HOUR;
 156   3                  break;
 157   3              default:
 158   3                  break;
 159   3              }
 160   2          }
 161   1          else
 162   1          {
 163   2              unsigned char setHour = LED8[0] * 10 + LED8[1];
 164   2              unsigned char setMinute = LED8[3] * 10 + LED8[4];
 165   2              unsigned char setSecond = LED8[6] * 10 + LED8[7];
 166   2              unsigned char setAlarmHour = LED8[3] * 10 + LED8[4];
 167   2              unsigned char setAlarmMinute = LED8[6] * 10 + LED8[7];
 168   2              switch (mode)
 169   2              {
 170   3              case SET_HOUR:
 171   3                  setHour++;
 172   3                  setHour %= 24;
 173   3                  LED8[0] = setHour / 10;
 174   3                  LED8[1] = setHour % 10;
 175   3                  break;
 176   3              case SET_MINUTE:
 177   3                  setMinute++;
 178   3                  setMinute %= 60;
 179   3                  LED8[3] = setMinute / 10;
C51 COMPILER V9.01   CLOCK                                                                 09/14/2023 20:10:43 PAGE 4   

 180   3                  LED8[4] = setMinute % 10;
 181   3                  break;
 182   3              case SET_SECOND:
 183   3                  setSecond++;
 184   3                  setSecond %= 60;
 185   3                  LED8[6] = setSecond / 10;
 186   3                  LED8[7] = setSecond % 10;
 187   3                  break;
 188   3              case STOPWATCH:
 189   3                  mode = STOPWATCH_START;
 190   3                  break;
 191   3              case STOPWATCH_START:
 192   3                  mode = STOPWATCH_PAUSE;
 193   3                  break;
 194   3              case STOPWATCH_PAUSE:
 195   3                  mode = STOPWATCH_START;
 196   3                  break;
 197   3              case ALARMCLOCK:
 198   3                  alarm = !alarm;
 199   3                  break;
 200   3              case ALARMCLOCK_HOUR:
 201   3                  setAlarmHour++;
 202   3                  setAlarmHour %= 24;
 203   3                  LED8[3] = setAlarmHour / 10;
 204   3                  LED8[4] = setAlarmHour % 10;
 205   3                  break;
 206   3              case ALARMCLOCK_MINUTE:
 207   3                  setAlarmMinute++;
 208   3                  setAlarmMinute %= 60;
 209   3                  LED8[6] = setAlarmMinute / 10;
 210   3                  LED8[7] = setAlarmMinute % 10;
 211   3                  break;
 212   3              default:
 213   3                  break;
 214   3              }
 215   2          }
 216   1      
 217   1          shortOrLang = 0;
 218   1      }
 219          
 220          // 长按处理程序
 221          void LongPress()
 222          {
 223   1          if (button == 0) // 如果按的是键A
 224   1          {
 225   2              switch (mode)
 226   2              {
 227   3              case SET:
 228   3                  mode = SET_HOUR;
 229   3                  break;
 230   3              case SET_HOUR:
 231   3              case SET_MINUTE:
 232   3              case SET_SECOND:
 233   3                  hour = LED8[0] * 10 + LED8[1];
 234   3                  minute = LED8[3] * 10 + LED8[4];
 235   3                  second = LED8[6] * 10 + LED8[7];
 236   3      
 237   3                  mode = SHOW;
 238   3                  break;
 239   3              case ALARMCLOCK:
 240   3                  mode = ALARMCLOCK_HOUR;
 241   3                  break;
C51 COMPILER V9.01   CLOCK                                                                 09/14/2023 20:10:43 PAGE 5   

 242   3              case ALARMCLOCK_HOUR:
 243   3              case ALARMCLOCK_MINUTE:
 244   3                  alarmHour = LED8[3] * 10 + LED8[4];
 245   3                  alarmMinute = LED8[6] * 10 + LED8[7];
 246   3      
 247   3                  mode = ALARMCLOCK;
 248   3                  break;
 249   3              default:
 250   3                  break;
 251   3              }
 252   2          }
 253   1          else
 254   1          {
 255   2              switch (mode)
 256   2              {
 257   3              case SHOW:
 258   3                  hourlyChime = !hourlyChime;
 259   3                  break;
 260   3              case SET_HOUR:
 261   3              case SET_MINUTE:
 262   3              case SET_SECOND:
 263   3                  mode = SHOW;
 264   3                  break;
 265   3              case STOPWATCH_PAUSE:
 266   3                  mode = STOPWATCH;
 267   3                  break;
 268   3              case ALARMCLOCK_HOUR:
 269   3              case ALARMCLOCK_MINUTE:
 270   3                  mode = ALARMCLOCK;
 271   3                  break;
 272   3              default:
 273   3                  break;
 274   3              }
 275   2          }
 276   1      
 277   1          shortOrLang = 0;
 278   1      }
 279          
 280          void Int0() interrupt 0
 281          {
 282   1          if (buttonDown == 0)
 283   1          {
 284   2              buttonDown = 1;
 285   2              button = 0;
 286   2          }
 287   1      }
 288          
 289          void Int1() interrupt 2
 290          {
 291   1          if (buttonDown == 0)
 292   1          {
 293   2              buttonDown = 1;
 294   2              button = 1;
 295   2          }
 296   1      }
 297          
 298          void SecondIncrease()
 299          {
 300   1          second++;
 301   1          if (second > 59)
 302   1          {
 303   2              second = 0;
C51 COMPILER V9.01   CLOCK                                                                 09/14/2023 20:10:43 PAGE 6   

 304   2              minute++;
 305   2          }
 306   1          if (minute > 59)
 307   1          {
 308   2              minute = 0;
 309   2              hour++;
 310   2          }
 311   1          if (hour > 23)
 312   1          {
 313   2              hour = 0;
 314   2          }
 315   1      }
 316          
 317          void Display(unsigned char enable)
 318          {
 319   1          enable >>= displayIndex;
 320   1          enable &= 1;
 321   1          if (enable == 1)
 322   1              DisplayOneCharOnAddr(LED8[displayIndex], displayIndex); // 显示数码管
 323   1          else
 324   1              DisplayOneCharOnAddr(17, displayIndex);
 325   1          displayIndex++;
 326   1          displayIndex %= 8; // 显示下一个数码管
 327   1      }
 328          
 329          unsigned char hourlyChimeTimes = 0;
 330          unsigned char alarmClockTimes = 0;
 331          
 332          unsigned int stopwatchMSecond = 0;
 333          unsigned char stopwatchSecond = 0;
 334          unsigned char stopwatchMinute = 0;
 335          
 336          // 定时器0中断服务函数
 337          void Timer0() interrupt 1
 338          {
 339   1      
 340   1          interruptCount++;
 341   1      
 342   1          TH0 = (65536 - INTERVAL * 1000) / 256;
 343   1          TL0 = (65536 - INTERVAL * 1000) % 256;
 344   1      
 345   1          if (interruptCount == (1000 / INTERVAL))
 346   1          { // 1秒
 347   2              interruptCount = 0;
 348   2              SecondIncrease();
 349   2          }
 350   1      
 351   1          if (buttonDown == 1)
 352   1          {
 353   2              Check();
 354   2          }
 355   1      
 356   1          if (shortOrLang == 1)
 357   1          {
 358   2              ShortPress();
 359   2          }
 360   1          else if (shortOrLang == 2)
 361   1          {
 362   2              LongPress();
 363   2          }
 364   1      
 365   1          if (mode == SHOW && alarm == 1)
C51 COMPILER V9.01   CLOCK                                                                 09/14/2023 20:10:43 PAGE 7   

 366   1          {
 367   2              if (hour == alarmHour && minute == alarmMinute && second == 00 && interruptCount == 0)
 368   2                  alarmClockTimes = 2 * ALARMCLOCKTIMES;
 369   2              if (alarmClockTimes != 0)
 370   2              {
 371   3                  if ((0 < interruptCount && interruptCount < (250 / INTERVAL)) || ((500 / INTERVAL) < interrupt
             -Count && interruptCount < (750 / INTERVAL)))
 372   3                      Chime = !Chime;
 373   3                  else
 374   3                      Chime = 0;
 375   3                  if (interruptCount % (250 / INTERVAL) == 0)
 376   3                  {
 377   4                      alarmClockTimes--;
 378   4                      Chime = 0;
 379   4                  }
 380   3              }
 381   2          }
 382   1      
 383   1          if (mode == SHOW && hourlyChime == 1)
 384   1          {
 385   2              if (hourlyChimeTimes == 0 && minute == 0 && second == 0 && interruptCount == 0)
 386   2                  hourlyChimeTimes = 2 * (HOURLYCHIMETIMES + 1); // 我也不知道这里为什么要加一，但事实就是它会响
             -HOURLYCHIMETIMES-1次，所以要加一补上。
 387   2              if (hourlyChimeTimes != 0)
 388   2              {
 389   3                  if (interruptCount > (500 / INTERVAL))
 390   3                      Chime = !Chime;
 391   3                  else
 392   3                      Chime = 0;
 393   3                  if (interruptCount % (500 / INTERVAL) == 0)
 394   3                  {
 395   4                      hourlyChimeTimes--;
 396   4                      Chime = 0;
 397   4                  }
 398   3              }
 399   2          }
 400   1      
 401   1          switch (mode)
 402   1          {
 403   2          case SHOW:
 404   2              LED8[0] = hour / 10; // 显示小时十位
 405   2              LED8[1] = hour % 10; // 显示小时个位
 406   2              LED8[2] = 16;
 407   2              LED8[3] = minute / 10; // 显示分钟十位
 408   2              LED8[4] = minute % 10; // 显示分钟个位
 409   2              LED8[5] = 16;
 410   2              LED8[6] = second / 10; // 显示秒十位
 411   2              LED8[7] = second % 10; // 显示秒个位
 412   2              Display(0xFF);
 413   2              break;
 414   2          case SET:
 415   2              if (interruptCount < (500 / INTERVAL))
 416   2                  Display(0xFF);
 417   2              else
 418   2                  Display(0); // 关闭数码管
 419   2              break;
 420   2          case SET_HOUR:
 421   2              if (interruptCount < (500 / INTERVAL))
 422   2                  Display(0xFF);
 423   2              else
 424   2                  Display(0xFC);
 425   2              break;
C51 COMPILER V9.01   CLOCK                                                                 09/14/2023 20:10:43 PAGE 8   

 426   2          case SET_MINUTE:
 427   2              if (interruptCount < (500 / INTERVAL))
 428   2                  Display(0xFF);
 429   2              else
 430   2                  Display(0xE7);
 431   2              break;
 432   2          case SET_SECOND:
 433   2              if (interruptCount < (500 / INTERVAL))
 434   2                  Display(0xFF);
 435   2              else
 436   2                  Display(0x3F);
 437   2              break;
 438   2          case STOPWATCH:
 439   2              stopwatchMSecond = 0;
 440   2              stopwatchSecond = 0;
 441   2              stopwatchMinute = 0;
 442   2              LED8[0] = stopwatchMinute / 10; // 显示分钟十位
 443   2              LED8[1] = stopwatchMinute % 10; // 显示分钟个位
 444   2              LED8[2] = 16;
 445   2              LED8[3] = stopwatchSecond / 10; // 显示秒十位
 446   2              LED8[4] = stopwatchSecond % 10; // 显示秒个位
 447   2              LED8[5] = 16;
 448   2              LED8[6] = stopwatchMSecond / 100;
 449   2              LED8[7] = (stopwatchMSecond % 100) / 10;
 450   2      
 451   2              Display(0xFF);
 452   2              break;
 453   2          case STOPWATCH_START:
 454   2              stopwatchMSecond += INTERVAL;
 455   2              if (stopwatchMSecond > 999)
 456   2              {
 457   3                  stopwatchMSecond = 0;
 458   3                  stopwatchSecond++;
 459   3              }
 460   2              if (stopwatchSecond > 59)
 461   2              {
 462   3                  stopwatchSecond = 0;
 463   3                  stopwatchMinute++;
 464   3              }
 465   2              if (stopwatchMinute > 59)
 466   2              {
 467   3                  stopwatchMinute = 0;
 468   3              }
 469   2      
 470   2              LED8[0] = stopwatchMinute / 10; // 显示分钟十位
 471   2              LED8[1] = stopwatchMinute % 10; // 显示分钟个位
 472   2              LED8[2] = 16;
 473   2              LED8[3] = stopwatchSecond / 10; // 显示秒十位
 474   2              LED8[4] = stopwatchSecond % 10; // 显示秒个位
 475   2              LED8[5] = 16;
 476   2              LED8[6] = stopwatchMSecond / 100;
 477   2              LED8[7] = (stopwatchMSecond % 100) / 10;
 478   2      
 479   2              Display(0xFF);
 480   2              break;
 481   2          case STOPWATCH_PAUSE:
 482   2              Display(0xFF);
 483   2          case ALARMCLOCK:
 484   2              LED8[3] = alarmHour / 10;
 485   2              LED8[4] = alarmHour % 10;
 486   2              LED8[5] = 16;
 487   2              LED8[6] = alarmMinute / 10;
C51 COMPILER V9.01   CLOCK                                                                 09/14/2023 20:10:43 PAGE 9   

 488   2              LED8[7] = alarmMinute % 10;
 489   2              if (alarm)
 490   2              {
 491   3                  LED8[0] = 17;
 492   3                  LED8[1] = 17;
 493   3                  LED8[2] = 17;
 494   3              }
 495   2              else
 496   2              {
 497   3                  LED8[0] = 0;
 498   3                  LED8[1] = 15;
 499   3                  LED8[2] = 15;
 500   3              }
 501   2              Display(0xFF);
 502   2              break;
 503   2          case ALARMCLOCK_HOUR:
 504   2              if (interruptCount < (500 / INTERVAL))
 505   2                  Display(0xFF);
 506   2              else
 507   2                  Display(0xE7);
 508   2              break;
 509   2          case ALARMCLOCK_MINUTE:
 510   2              if (interruptCount < (500 / INTERVAL))
 511   2                  Display(0xFF);
 512   2              else
 513   2                  Display(0x3F);
 514   2              break;
 515   2          default:
 516   2              break;
 517   2          }
 518   1      }
 519          
 520          void Init()
 521          {
 522   1          Chime = 0;
 523   1      
 524   1          EA = 1;      // 开启总中断
 525   1          IT0 = 1;     // 设置外部中断0为边沿触发方式
 526   1          EX0 = 1;     // 允许外部中断0
 527   1          IT1 = 1;     // 设置外部中断1为边沿触发方式
 528   1          EX1 = 1;     // 允许外部中断1
 529   1          PT0 = 1;     // 计时器0中断优先级为最高
 530   1          TMOD = 0x01; // 设置计时器0工作在方式1
 531   1          ET0 = 1;     // 允许计时器0中断
 532   1          TR0 = 1;     // 启动计时器
 533   1          TH0 = (65536 - INTERVAL * 1000) / 256;
 534   1          TL0 = (65536 - INTERVAL * 1000) % 256;
 535   1      }
 536          
 537          void main()
 538          {
 539   1          Init();
 540   1          while (1)
 541   1          {
 542   2              ;
 543   2          }
 544   1      }
 545          
 546          // 向HC595发送一个字节
 547          void SEG_Send595OneByte(unsigned char ucData)
 548          {
 549   1          unsigned char i;
C51 COMPILER V9.01   CLOCK                                                                 09/14/2023 20:10:43 PAGE 10  

 550   1      
 551   1          for (i = 0; i < 8; i++) // 8位数据依次写入，先写最低位
 552   1          {
 553   2              SEG_DS = (ucData & 0x80); // 先读入高位   x&0x80;
 554   2              SEG_SHCP = 0;
 555   2              SEG_SHCP = 1;
 556   2              SEG_SHCP = 0; // SHCP引脚的上升沿移入数据
 557   2              ucData <<= 1; // 数据左移
 558   2          }
 559   1      }
 560          
 561          /*******************************************************
 562          函数功能：在指定位置显示一个数据
 563          参数说明：Data是要显示的数据，Addr是在第几位显示。
 564          
 565          Addr取值范围是0~9。
 566          Addr=0~7时，选择的是显示在第几位数码管上;
 567          Addr=8  时，同时选中8位数码管，即打开所有数码管
 568          Addr=9  时，关闭8位数码管
 569          
 570          8位数码管，左数依次为第0位，第1位...第7位。
 571          
 572          *******************************************************/
 573          void DisplayOneCharOnAddr(unsigned char Data, unsigned char Addr)
 574          {
 575   1          SEG_Send595OneByte(Seg_Addr[Addr]); // 显示在哪一个数码管上
 576   1          if (hourlyChime == 1 && displayIndex == 7)
 577   1              SEG_Send595OneByte(Seg_Data[Data] & 0x7F); // 显示的数据
 578   1          else
 579   1              SEG_Send595OneByte(Seg_Data[Data]); // 显示的数据
 580   1          SEG_STCP = 0;
 581   1          SEG_STCP = 1; // STCP引脚的上升沿更新数据
 582   1          SEG_STCP = 0;
 583   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1538    ----
   CONSTANT SIZE    =     28    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     26       5
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
