C51 COMPILER V9.01   CLOCK                                                                 09/18/2023 17:25:05 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE CLOCK
OBJECT MODULE PLACED IN Clock.OBJ
COMPILER INVOKED BY: D:\Software\Keil\C51\BIN\C51.EXE Clock.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <REG51.H>
   2          
   3          #define INTERVAL 1 // º‰∏Ù1∫¡√Î
   4          
   5          #define INIT_HOUR 23   // ≥ı ºªØ–° ±
   6          #define INIT_MINUTE 59 // ≥ı ºªØ∑÷÷”
   7          #define INIT_SECOND 58 // ≥ı ºªØ√Î
   8          
   9          #define INIT_YEAR 2020 // ≥ı ºªØƒÍ
  10          #define INIT_MONTH 2   // ≥ı ºªØ‘¬
  11          #define INIT_DAY 28    // ≥ı ºªØ»’
  12          
  13          #define INIT_ALARM 0         // ≥ı ºªØƒ÷÷”π¶ƒ‹£¨1±Ì æœÏ£¨0±Ì æ≤ªœÏ
  14          #define INIT_ALARM_HOUR 23   // ≥ı ºªØƒ÷÷”–° ±
  15          #define INIT_ALARM_MINUTE 59 // ≥ı ºªØƒ÷÷”∑÷÷”
  16          #define INIT_ALARM_WEEKDAY 0 // ≥ı ºªØƒ÷÷”–«∆⁄
  17          #define ALARMCLOCKTIMES 6    // ƒ÷÷”œÏ¡Â¥Œ ˝
  18          
  19          #define INIT_HOURLY_CHIME 0 // ≥ı ºªØ’˚µ„±® ±π¶ƒ‹£¨1±Ì æø™£¨0±Ì æπÿ
  20          #define HOURLYCHIMETIMES 3  // ’˚µ„œÏ¡Â¥Œ ˝
  21          
  22          unsigned char hour = INIT_HOUR;     // ≥ı ºªØ–° ±
  23          unsigned char minute = INIT_MINUTE; // ≥ı ºªØ∑÷÷”
  24          unsigned char second = INIT_SECOND; // ≥ı ºªØ√Î
  25          
  26          unsigned int year = INIT_YEAR;    // ≥ı ºªØƒÍ
  27          unsigned char month = INIT_MONTH; // ≥ı ºªØ‘¬
  28          unsigned char day = INIT_DAY;     // ≥ı ºªØ»’
  29          
  30          unsigned char weekday = 0; // –«∆⁄£¨–«∆⁄≥ı ºªØ»ŒŒÒ”…init()∫Ø ˝∏∫‘
  31          
  32          unsigned char alarmHour = INIT_ALARM_HOUR;       // ƒ÷÷” ±
  33          unsigned char alarmMinute = INIT_ALARM_MINUTE;   // ƒ÷÷”∑÷
  34          unsigned char alarmWeekday = INIT_ALARM_WEEKDAY; // ƒ÷÷”–«∆⁄π¶ƒ‹£¨µÕ0ŒªŒ™1±Ì æ÷‹»’œÏ£¨µÕ1ŒªŒ™1±Ì æ÷‹“ªœÏ£¨
             -“‘¥À¿‡Õ∆
  35          
  36          bit alarm = INIT_ALARM; // ƒ÷÷”π¶ƒ‹£¨1±Ì æœÏ£¨0±Ì æ≤ªœÏ
  37          
  38          bit hourlyChime = INIT_HOURLY_CHIME; // ’˚µ„±® ±π¶ƒ‹£¨1±Ì æø™£¨0±Ì æπÿ
  39          
  40          bit buttonDown = 0;            // ”√”⁄≈–∂œ «∑Ò”–∞¥º¸∞¥œ¬£¨1Œ™”–£¨0Œ™Œﬁ
  41          bit button = 0;                // ”√”⁄≈–∂œ∞¥œ¬µƒ «ƒƒ∏ˆ∞¥º¸
  42          unsigned int checkCount = 0;   // ”√”⁄ºÏ≤È∞¥º¸ «≥§∞¥ªπ «∂Ã∞¥£¨√ø∞¥“ª∫¡√Î∏√±‰¡øº”“ª
  43          unsigned char shortOrLang = 0; // ”√”⁄±Ì æ∞¥º¸ «≥§∞¥ªπ «∂Ã∞¥µƒ±Í÷æ£¨0±Ì æŒﬁ–ß£¨1±Ì æ∂Ã∞¥£¨2±Ì æ≥§∞¥
  44          
  45          unsigned char displayIndex = 0;                   // µ±«∞µ„¡¡µƒ «ƒ«∏ˆ ˝¬Îπ‹£¨¥”◊ÛµΩ”“∑÷±Œ™0,1,...,7
  46          unsigned char LED8[8] = {0, 0, 0, 0, 0, 0, 0, 0}; // √ø∏ˆ ˝¬Îπ‹œ‘ æµƒ ˝◊÷
  47          unsigned char LED8Point = 0;                      // √ø∏ˆ ˝¬Îπ‹ «∑Ò“™œ‘ æ–° ˝µ„£¨µÕ0ŒªŒ™1±Ì æµ⁄0∏ˆ ˝¬Îπ‹“™
             -œ‘ æ–° ˝µ„
  48          
  49          unsigned char hourlyChimeTimes = 0; // º«¬º’˚µ„±® ±µƒœÏ¡Â¥Œ ˝
  50          unsigned char alarmClockTimes = 0;  // º«¬ºƒ÷÷”µƒœÏ¡Â¥Œ ˝
  51          
  52          unsigned int stopwatchMSecond = 0; // √Î±Ìµƒ∫¡√Î ˝
  53          unsigned char stopwatchSecond = 0; // √Î±Ìµƒ√Î ˝
C51 COMPILER V9.01   CLOCK                                                                 09/18/2023 17:25:05 PAGE 2   

  54          unsigned char stopwatchMinute = 0; // √Î±Ìµƒ∑÷÷” ˝
  55          
  56          unsigned char setAlarmHour = INIT_ALARM_HOUR;       // …Ë÷√ƒ÷÷” ±µƒ±‰¡ø
  57          unsigned char setAlarmMinute = INIT_ALARM_MINUTE;   // …Ë÷√ƒ÷÷”∑÷µƒ±‰¡ø
  58          unsigned char setAlarmWeekday = INIT_ALARM_WEEKDAY; // …Ë÷√ƒ÷÷”–«∆⁄µƒ±‰¡ø£¨µÕ0ŒªŒ™1±Ì æ÷‹»’œÏ£¨µÕ1ŒªŒ™1±Ì 
             -æ÷‹“ªœÏ£¨“‘¥À¿‡Õ∆
  59          
  60          enum MODE
  61          {
  62              SHOW_TIME,            // œ‘ æ ±º‰ƒ£ Ω
  63              SHOW_DATE,            // œ‘ æ»’∆⁄ƒ£ Ω
  64              SET_YEAR,             // …Ë÷√ƒÍƒ£ Ω
  65              SET_MONTH,            // …Ë÷√‘¬ƒ£ Ω
  66              SET_DAY,              // …Ë÷√»’ƒ£ Ω
  67              SET_HOUR,             // …Ë÷√ ±ƒ£ Ω
  68              SET_MINUTE,           // …Ë÷√∑÷ƒ£ Ω
  69              SET_SECOND,           // …Ë÷√√Îƒ£ Ω
  70              STOPWATCH,            // √Î±Ìƒ£ Ω
  71              STOPWATCH_START,      // √Î±Ìº∆ ±ƒ£ Ω
  72              STOPWATCH_PAUSE,      // √Î±Ì‘›Õ£ƒ£ Ω
  73              ALARMCLOCK,           // ƒ÷÷”ƒ£ Ω
  74              ALARMCLOCK_HOUR,      // …Ë÷√ƒ÷÷” ±ƒ£ Ω
  75              ALARMCLOCK_MINUTE,    // …Ë÷√ƒ÷÷”∑÷ƒ£ Ω
  76              ALARMCLOCK_SUNDAY,    // …Ë÷√ƒ÷÷”÷‹»’ƒ£ Ω
  77              ALARMCLOCK_MONDAY,    // …Ë÷√ƒ÷÷”÷‹“ªƒ£ Ω
  78              ALARMCLOCK_TUESDAY,   // …Ë÷√ƒ÷÷”÷‹∂˛ƒ£ Ω
  79              ALARMCLOCK_WEDNESDAY, // …Ë÷√ƒ÷÷”÷‹»˝ƒ£ Ω
  80              ALARMCLOCK_THURSDAY,  // …Ë÷√ƒ÷÷”÷‹Àƒƒ£ Ω
  81              ALARMCLOCK_FRIDAY,    // …Ë÷√ƒ÷÷”÷‹ŒÂƒ£ Ω
  82              ALARMCLOCK_SATURDAY   // …Ë÷√ƒ÷÷”÷‹¡˘ƒ£ Ω
  83          };
  84          
  85          unsigned char mode = SHOW_TIME; // ƒ£ Ω
  86          
  87          unsigned int interruptCount = 0; // ÷–∂œ¥Œ ˝
  88          
  89          sbit SEG_DS = P2 ^ 0;   // 74HC595–æ∆¨µƒ ˝æ›“˝Ω≈
  90          sbit SEG_SHCP = P2 ^ 1; // 74HC595–æ∆¨µƒøÿ÷∆“˝Ω≈£¨…œ…˝—ÿ“∆»Î ˝æ›
  91          sbit SEG_STCP = P2 ^ 2; // 74HC595–æ∆¨µƒøÿ÷∆“˝Ω≈£¨…œ…˝—ÿ∏¸–¬ ˝æ›
  92          
  93          sbit Chime = P2 ^ 3; // ∑‰√˘∆˜
  94          
  95          sbit P3_2 = P3 ^ 2; // Õ‚≤ø÷–∂œ0µƒøÿ÷∆“˝Ω≈
  96          sbit P3_3 = P3 ^ 3; // Õ‚≤ø÷–∂œ1µƒøÿ÷∆“˝Ω≈
  97          
  98          unsigned char code Seg_Data[] = {
  99              // π≤—Ù ˝¬Îπ‹µƒ±‡¬Î£¨≤¢Ω´ ˝æ›∂®“Â‘⁄CODE«¯
 100              0xc0, /*0*/
 101              0xF9, /*1*/
 102              0xA4, /*2*/
 103              0xB0, /*3*/
 104              0x99, /*4*/
 105              0x92, /*5*/
 106              0x82, /*6*/
 107              0xF8, /*7*/
 108              0x80, /*8*/
 109              0x90, /*9*/
 110              0x88, /*A*/
 111              0x83, /*b*/
 112              0xC6, /*C*/
 113              0xA1, /*d*/
 114              0x86, /*E*/
C51 COMPILER V9.01   CLOCK                                                                 09/18/2023 17:25:05 PAGE 3   

 115              0x8E, /*F*/
 116              0xBF, /*-*/
 117              0xFF, /*OFF*/
 118          };
 119          
 120          unsigned char code Seg_Date[] = {
 121              31, // 1‘¬
 122              28, // 2‘¬
 123              31, // 3‘¬
 124              30, // 4‘¬
 125              31, // 5‘¬
 126              30, // 6‘¬
 127              31, // 7‘¬
 128              31, // 8‘¬
 129              30, // 9‘¬
 130              31, // 10‘¬
 131              30, // 11‘¬
 132              31  // 12‘¬
 133          };
 134          
 135          unsigned char code Seg_Addr[] = {
 136              //  ˝¬Îπ‹Œª—°±‡¬Î£¨øÿ÷∆œ‘ æ8Œª÷–µƒµ⁄º∏Œª
 137              0x01,
 138              0x02,
 139              0x04,
 140              0x08,
 141              0x10,
 142              0x20,
 143              0x40,
 144              0x80,
 145              0xFF, // ALL ON
 146              0x00  // OFF
 147          };
 148          
 149          // ≥ı ºªØ∫Ø ˝
 150          void Init();
 151          // ºÏ≤Èµ±«∞∞¥º¸ «≥§∞¥ªπ «∂Ã∞¥
 152          void Check();
 153          // ∞¥º¸∂Ã∞¥¥¶¿Ì≥Ã–Ú
 154          void ShortPress();
 155          // ∞¥º¸≥§∞¥¥¶¿Ì≥Ã–Ú
 156          void LongPress();
 157          // √Î ˝‘ˆº”¥¶¿Ì≥Ã–Ú
 158          void SecondIncrease();
 159          // »’∆⁄‘ˆº”¥¶¿Ì≥Ã–Ú
 160          void DateIncrease();
 161          // ∏¸–¬»’∆⁄
 162          void UpdateWeekday();
 163          // ºÏ≤È»’∆⁄≥Ã–Ú£¨∑µªÿ0±Ì æ»’∆⁄ŒﬁŒÛ£¨∑µªÿ1±Ì æ»’∆⁄”–ŒÛ
 164          bit CheckDate(unsigned int year, unsigned char month, unsigned char day);
 165          // œ‘ æ∫Ø ˝£¨”√”⁄œ‘ æLED8 ˝◊È£¨“‘º∞LED8Point÷–µƒƒ⁄»›£¨≤Œ ˝∑÷±Œ™ ˝◊÷µƒ πƒ‹£¨–° ˝µ„µƒ πƒ‹£¨»Ù≤Œ ˝µƒµÕ0ŒªŒ™0
             -£¨‘Úµ⁄0Œª ˝¬Îπ‹≤ªœ‘ æ∂‘”¶ƒ⁄»›°£
 166          void Display(unsigned char numEnable, unsigned char pointEnable);
 167          // œÚHC595∑¢ÀÕ“ª∏ˆ◊÷Ω⁄
 168          void SEG_Send595OneByte(unsigned char ucData);
 169          
 170          void main()
 171          {
 172   1          Init();
 173   1          while (1)
 174   1          {
 175   2              ;
C51 COMPILER V9.01   CLOCK                                                                 09/18/2023 17:25:05 PAGE 4   

 176   2          }
 177   1      }
 178          
 179          // ≥ı ºªØ∫Ø ˝
 180          void Init()
 181          {
 182   1          // ≥ı ºªØ–«∆⁄
 183   1          UpdateWeekday();
 184   1      
 185   1          Chime = 0; // ≥ı ºªØ∑‰√˘∆˜“˝Ω≈Œ™0£¨∑¿÷πÀªµ∑‰√˘∆˜
 186   1      
 187   1          EA = 1;      // ø™∆Ù◊‹÷–∂œ
 188   1          IT0 = 1;     // …Ë÷√Õ‚≤ø÷–∂œ0Œ™±ﬂ—ÿ¥•∑¢∑Ω Ω
 189   1          EX0 = 1;     // ‘ –ÌÕ‚≤ø÷–∂œ0
 190   1          IT1 = 1;     // …Ë÷√Õ‚≤ø÷–∂œ1Œ™±ﬂ—ÿ¥•∑¢∑Ω Ω
 191   1          EX1 = 1;     // ‘ –ÌÕ‚≤ø÷–∂œ1
 192   1          PT0 = 1;     // º∆ ±∆˜0÷–∂œ”≈œ»º∂Œ™◊Ó∏ﬂ
 193   1          TMOD = 0x01; // …Ë÷√º∆ ±∆˜0π§◊˜‘⁄∑Ω Ω1
 194   1          ET0 = 1;     // ‘ –Ìº∆ ±∆˜0÷–∂œ
 195   1          TR0 = 1;     // ∆Ù∂Øº∆ ±∆˜
 196   1          TH0 = (65536 - INTERVAL * 1000) / 256;
 197   1          TL0 = (65536 - INTERVAL * 1000) % 256;
 198   1      }
 199          
 200          // ºÏ≤Èµ±«∞∞¥º¸ «≥§∞¥ªπ «∂Ã∞¥
 201          void Check()
 202          {
 203   1          checkCount++; // ∞¥º¸ ±º‰º∆ ˝£¨√øπ˝“ª∫¡√Îº”“ª°£
 204   1      
 205   1          if (checkCount < 10 / INTERVAL) // 10ms—”≥Ÿ»•∂∂∂Ø
 206   1              return;
 207   1      
 208   1          if (checkCount > 1010 / INTERVAL) // »Áπ˚∞¥œ¬ ±º‰¥Û”⁄“ª√Î£¨Œ™≥§∞¥°£
 209   1          {
 210   2              shortOrLang = 2;
 211   2              checkCount = 0;
 212   2              buttonDown = 0;
 213   2          }
 214   1          else // »Áπ˚∞¥œ¬ ±º‰–°”⁄“ª√Î£¨‘Ú≈–∂œ «∑ÒÀ…ø™£¨»ÙÀ…ø™£¨‘ÚŒ™∂Ã∞¥£¨∑Ò‘ÚºÃ–¯º∆ ˝°£
 215   1          {
 216   2              if ((button == 0 && P3_2 == 1) || (button == 1 && P3_3 == 1))
 217   2              {
 218   3                  shortOrLang = 1;
 219   3                  checkCount = 0;
 220   3                  buttonDown = 0;
 221   3              }
 222   2          }
 223   1      }
 224          
 225          // ∞¥º¸∂Ã∞¥¥¶¿Ì≥Ã–Ú
 226          void ShortPress()
 227          {
 228   1          if (button == 0) // »Áπ˚∞¥µƒ «º¸A
 229   1          {
 230   2              switch (mode)
 231   2              {
 232   3              case SHOW_TIME:
 233   3                  mode = STOPWATCH;
 234   3                  break;
 235   3              case STOPWATCH:
 236   3                  mode = ALARMCLOCK;
 237   3                  break;
C51 COMPILER V9.01   CLOCK                                                                 09/18/2023 17:25:05 PAGE 5   

 238   3              case ALARMCLOCK:
 239   3                  mode = SHOW_TIME;
 240   3                  break;
 241   3              case SET_HOUR:
 242   3                  mode = SET_MINUTE;
 243   3                  break;
 244   3              case SET_MINUTE:
 245   3                  mode = SET_SECOND;
 246   3                  break;
 247   3              case SET_SECOND:
 248   3                  mode = SET_HOUR;
 249   3                  break;
 250   3              case SET_YEAR:
 251   3                  mode = SET_MONTH;
 252   3                  break;
 253   3              case SET_MONTH:
 254   3                  mode = SET_DAY;
 255   3                  break;
 256   3              case SET_DAY:
 257   3                  mode = SET_YEAR;
 258   3                  break;
 259   3              case ALARMCLOCK_HOUR:
 260   3                  mode = ALARMCLOCK_MINUTE;
 261   3                  break;
 262   3              case ALARMCLOCK_MINUTE:
 263   3                  LED8[0] = setAlarmWeekday & 1;
 264   3                  LED8[1] = setAlarmWeekday >> 1 & 1;
 265   3                  LED8[2] = setAlarmWeekday >> 2 & 1;
 266   3                  LED8[3] = setAlarmWeekday >> 3 & 1;
 267   3                  LED8[4] = setAlarmWeekday >> 4 & 1;
 268   3                  LED8[5] = setAlarmWeekday >> 5 & 1;
 269   3                  LED8[6] = setAlarmWeekday >> 6 & 1;
 270   3                  LED8[7] = 17;
 271   3                  LED8Point = setAlarmWeekday;
 272   3                  mode = ALARMCLOCK_SUNDAY;
 273   3                  break;
 274   3              case ALARMCLOCK_SUNDAY:
 275   3                  mode = ALARMCLOCK_MONDAY;
 276   3                  break;
 277   3              case ALARMCLOCK_MONDAY:
 278   3                  mode = ALARMCLOCK_TUESDAY;
 279   3                  break;
 280   3              case ALARMCLOCK_TUESDAY:
 281   3                  mode = ALARMCLOCK_WEDNESDAY;
 282   3                  break;
 283   3              case ALARMCLOCK_WEDNESDAY:
 284   3                  mode = ALARMCLOCK_THURSDAY;
 285   3                  break;
 286   3              case ALARMCLOCK_THURSDAY:
 287   3                  mode = ALARMCLOCK_FRIDAY;
 288   3                  break;
 289   3              case ALARMCLOCK_FRIDAY:
 290   3                  mode = ALARMCLOCK_SATURDAY;
 291   3                  break;
 292   3              case ALARMCLOCK_SATURDAY:
 293   3                  LED8[3] = setAlarmHour / 10;
 294   3                  LED8[4] = setAlarmHour % 10;
 295   3                  LED8[5] = 16;
 296   3                  LED8[6] = setAlarmMinute / 10;
 297   3                  LED8[7] = setAlarmMinute % 10;
 298   3                  if (alarm)
 299   3                  {
C51 COMPILER V9.01   CLOCK                                                                 09/18/2023 17:25:05 PAGE 6   

 300   4                      LED8[0] = 17;
 301   4                      LED8[1] = 17;
 302   4                      LED8[2] = 17;
 303   4                  }
 304   3                  else
 305   3                  {
 306   4                      LED8[0] = 0;
 307   4                      LED8[1] = 15;
 308   4                      LED8[2] = 15;
 309   4                  }
 310   3                  LED8Point = setAlarmWeekday;
 311   3                  mode = ALARMCLOCK_HOUR;
 312   3                  break;
 313   3              default:
 314   3                  break;
 315   3              }
 316   2          }
 317   1          else
 318   1          {
 319   2              unsigned char setHour = LED8[0] * 10 + LED8[1];
 320   2              unsigned char setMinute = LED8[3] * 10 + LED8[4];
 321   2              unsigned char setSecond = LED8[6] * 10 + LED8[7];
 322   2              switch (mode)
 323   2              {
 324   3              case SHOW_TIME:
 325   3                  mode = SHOW_DATE;
 326   3                  break;
 327   3              case SHOW_DATE:
 328   3                  mode = SHOW_TIME;
 329   3                  break;
 330   3              case SET_YEAR:
 331   3                  year++;
 332   3                  year %= 10000;
 333   3                  LED8[0] = year / 1000;
 334   3                  LED8[1] = year / 100 % 10;
 335   3                  LED8[2] = year / 10 % 10;
 336   3                  LED8[3] = year % 10;
 337   3                  UpdateWeekday();
 338   3                  break;
 339   3              case SET_MONTH:
 340   3                  month = (month % 12) + 1;
 341   3                  LED8[4] = month / 10;
 342   3                  LED8[5] = month % 10;
 343   3                  UpdateWeekday();
 344   3                  break;
 345   3              case SET_DAY:
 346   3                  if (((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) && month == 2) // »ÚƒÍ2‘¬
 347   3                      day = (day % 29) + 1;
 348   3                  else
 349   3                      day = (day % Seg_Date[month - 1]) + 1;
 350   3                  LED8[6] = day / 10;
 351   3                  LED8[7] = day % 10;
 352   3                  UpdateWeekday();
 353   3                  break;
 354   3              case SET_HOUR:
 355   3                  setHour++;
 356   3                  setHour %= 24;
 357   3                  LED8[0] = setHour / 10;
 358   3                  LED8[1] = setHour % 10;
 359   3                  break;
 360   3              case SET_MINUTE:
 361   3                  setMinute++;
C51 COMPILER V9.01   CLOCK                                                                 09/18/2023 17:25:05 PAGE 7   

 362   3                  setMinute %= 60;
 363   3                  LED8[3] = setMinute / 10;
 364   3                  LED8[4] = setMinute % 10;
 365   3                  break;
 366   3              case SET_SECOND:
 367   3                  setSecond++;
 368   3                  setSecond %= 60;
 369   3                  LED8[6] = setSecond / 10;
 370   3                  LED8[7] = setSecond % 10;
 371   3                  break;
 372   3              case STOPWATCH:
 373   3                  mode = STOPWATCH_START;
 374   3                  break;
 375   3              case STOPWATCH_START:
 376   3                  mode = STOPWATCH_PAUSE;
 377   3                  break;
 378   3              case STOPWATCH_PAUSE:
 379   3                  mode = STOPWATCH_START;
 380   3                  break;
 381   3              case ALARMCLOCK:
 382   3                  alarm = !alarm;
 383   3                  break;
 384   3              case ALARMCLOCK_HOUR:
 385   3                  setAlarmHour++;
 386   3                  setAlarmHour %= 24;
 387   3                  LED8[3] = setAlarmHour / 10;
 388   3                  LED8[4] = setAlarmHour % 10;
 389   3                  break;
 390   3              case ALARMCLOCK_MINUTE:
 391   3                  setAlarmMinute++;
 392   3                  setAlarmMinute %= 60;
 393   3                  LED8[6] = setAlarmMinute / 10;
 394   3                  LED8[7] = setAlarmMinute % 10;
 395   3                  break;
 396   3              case ALARMCLOCK_SUNDAY:
 397   3                  LED8[0] = LED8[0] ^ 1;
 398   3                  setAlarmWeekday = setAlarmWeekday ^ (1 << 0); // µÕ0Œª»°∑¥
 399   3                  LED8Point = setAlarmWeekday;
 400   3                  break;
 401   3              case ALARMCLOCK_MONDAY:
 402   3                  LED8[1] = LED8[1] ^ 1;
 403   3                  setAlarmWeekday = setAlarmWeekday ^ (1 << 1); // µÕ1Œª»°∑¥
 404   3                  LED8Point = setAlarmWeekday;
 405   3                  break;
 406   3              case ALARMCLOCK_TUESDAY:
 407   3                  LED8[2] = LED8[2] ^ 1;
 408   3                  setAlarmWeekday = setAlarmWeekday ^ (1 << 2); // µÕ2Œª»°∑¥
 409   3                  LED8Point = setAlarmWeekday;
 410   3                  break;
 411   3              case ALARMCLOCK_WEDNESDAY:
 412   3                  LED8[3] = LED8[3] ^ 1;
 413   3                  setAlarmWeekday = setAlarmWeekday ^ (1 << 3); // µÕ3Œª»°∑¥
 414   3                  LED8Point = setAlarmWeekday;
 415   3                  break;
 416   3              case ALARMCLOCK_THURSDAY:
 417   3                  LED8[4] = LED8[4] ^ 1;
 418   3                  setAlarmWeekday = setAlarmWeekday ^ (1 << 4); // µÕ4Œª»°∑¥
 419   3                  LED8Point = setAlarmWeekday;
 420   3                  break;
 421   3              case ALARMCLOCK_FRIDAY:
 422   3                  LED8[5] = LED8[5] ^ 1;
 423   3                  setAlarmWeekday = setAlarmWeekday ^ (1 << 5); // µÕ5Œª»°∑¥
C51 COMPILER V9.01   CLOCK                                                                 09/18/2023 17:25:05 PAGE 8   

 424   3                  LED8Point = setAlarmWeekday;
 425   3                  break;
 426   3              case ALARMCLOCK_SATURDAY:
 427   3                  LED8[6] = LED8[6] ^ 1;
 428   3                  setAlarmWeekday = setAlarmWeekday ^ (1 << 6); // µÕ6Œª»°∑¥
 429   3                  LED8Point = setAlarmWeekday;
 430   3                  break;
 431   3              default:
 432   3                  break;
 433   3              }
 434   2          }
 435   1      
 436   1          shortOrLang = 0; // ÷ÿ÷√∞¥º¸±Í÷æ
 437   1      }
 438          
 439          // ∞¥º¸≥§∞¥¥¶¿Ì≥Ã–Ú
 440          void LongPress()
 441          {
 442   1          if (button == 0) // »Áπ˚∞¥µƒ «º¸A
 443   1          {
 444   2              switch (mode)
 445   2              {
 446   3              case SHOW_TIME:
 447   3                  mode = SET_HOUR;
 448   3                  break;
 449   3              case SHOW_DATE:
 450   3                  mode = SET_YEAR;
 451   3                  break;
 452   3              case SET_YEAR:
 453   3              case SET_MONTH:
 454   3              case SET_DAY:
 455   3                  if (!CheckDate(year, month, day)) // »Áπ˚»’∆⁄ŒﬁŒÛ≤≈ƒ‹»∑∂®
 456   3                  {
 457   4                      mode = SHOW_DATE;
 458   4                  }
 459   3                  break;
 460   3              case SET_HOUR:
 461   3              case SET_MINUTE:
 462   3              case SET_SECOND:
 463   3                  hour = LED8[0] * 10 + LED8[1];
 464   3                  minute = LED8[3] * 10 + LED8[4];
 465   3                  second = LED8[6] * 10 + LED8[7];
 466   3                  mode = SHOW_TIME;
 467   3                  break;
 468   3              case ALARMCLOCK:
 469   3                  mode = ALARMCLOCK_HOUR;
 470   3                  break;
 471   3              case ALARMCLOCK_HOUR:
 472   3              case ALARMCLOCK_MINUTE:
 473   3              case ALARMCLOCK_SUNDAY:
 474   3              case ALARMCLOCK_MONDAY:
 475   3              case ALARMCLOCK_TUESDAY:
 476   3              case ALARMCLOCK_WEDNESDAY:
 477   3              case ALARMCLOCK_THURSDAY:
 478   3              case ALARMCLOCK_FRIDAY:
 479   3              case ALARMCLOCK_SATURDAY:
 480   3                  alarmHour = setAlarmHour;
 481   3                  alarmMinute = setAlarmMinute;
 482   3                  alarmWeekday = setAlarmWeekday;
 483   3                  mode = ALARMCLOCK;
 484   3                  break;
 485   3              default:
C51 COMPILER V9.01   CLOCK                                                                 09/18/2023 17:25:05 PAGE 9   

 486   3                  break;
 487   3              }
 488   2          }
 489   1          else
 490   1          {
 491   2              switch (mode)
 492   2              {
 493   3              case SHOW_TIME:
 494   3                  hourlyChime = !hourlyChime;
 495   3                  break;
 496   3              case SET_HOUR:
 497   3              case SET_MINUTE:
 498   3              case SET_SECOND:
 499   3                  mode = SHOW_TIME;
 500   3                  break;
 501   3              case SET_YEAR:
 502   3                  year--;
 503   3                  year %= 10000;
 504   3                  LED8[0] = year / 1000;
 505   3                  LED8[1] = year / 100 % 10;
 506   3                  LED8[2] = year / 10 % 10;
 507   3                  LED8[3] = year % 10;
 508   3                  UpdateWeekday();
 509   3                  break;
 510   3              case SET_MONTH:
 511   3                  month += 10;
 512   3                  month = (month % 12) + 1;
 513   3                  LED8[4] = month / 10;
 514   3                  LED8[5] = month % 10;
 515   3                  UpdateWeekday();
 516   3                  break;
 517   3              case SET_DAY:
 518   3                  if (((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) && month == 2)
 519   3                  {
 520   4                      day += 29 - 2;
 521   4                      day = (day % 29) + 1;
 522   4                  }
 523   3                  else
 524   3                  {
 525   4                      day += Seg_Date[month - 1] - 2;
 526   4                      day = (day % Seg_Date[month - 1]) + 1;
 527   4                  }
 528   3                  LED8[6] = day / 10;
 529   3                  LED8[7] = day % 10;
 530   3                  UpdateWeekday();
 531   3                  break;
 532   3              case STOPWATCH_PAUSE:
 533   3                  mode = STOPWATCH;
 534   3                  break;
 535   3              case ALARMCLOCK_HOUR:
 536   3              case ALARMCLOCK_MINUTE:
 537   3              case ALARMCLOCK_SUNDAY:
 538   3              case ALARMCLOCK_MONDAY:
 539   3              case ALARMCLOCK_TUESDAY:
 540   3              case ALARMCLOCK_WEDNESDAY:
 541   3              case ALARMCLOCK_THURSDAY:
 542   3              case ALARMCLOCK_FRIDAY:
 543   3              case ALARMCLOCK_SATURDAY:
 544   3                  setAlarmHour = alarmHour;
 545   3                  setAlarmMinute = alarmMinute;
 546   3                  setAlarmWeekday = alarmWeekday;
 547   3                  mode = ALARMCLOCK;
C51 COMPILER V9.01   CLOCK                                                                 09/18/2023 17:25:05 PAGE 10  

 548   3                  break;
 549   3              default:
 550   3                  break;
 551   3              }
 552   2          }
 553   1      
 554   1          shortOrLang = 0; // ÷ÿ÷√∞¥º¸±Í÷æ
 555   1      }
 556          
 557          // √Î ˝‘ˆº”¥¶¿Ì≥Ã–Ú
 558          void SecondIncrease()
 559          {
 560   1          second++;
 561   1          if (second > 59)
 562   1          {
 563   2              second = 0;
 564   2              minute++;
 565   2          }
 566   1          if (minute > 59)
 567   1          {
 568   2              minute = 0;
 569   2              hour++;
 570   2          }
 571   1          if (hour > 23)
 572   1          {
 573   2              hour = 0;
 574   2          }
 575   1      }
 576          
 577          // »’∆⁄‘ˆº”¥¶¿Ì≥Ã–Ú
 578          void DateIncrease()
 579          {
 580   1          day++;
 581   1          if (CheckDate(year, month, day))
 582   1          {
 583   2              day = 1;
 584   2              month++;
 585   2              if (month > 12)
 586   2              {
 587   3                  month = 1;
 588   3                  year++;
 589   3              }
 590   2          }
 591   1      }
 592          
 593          // ∏¸–¬»’∆⁄
 594          void UpdateWeekday()
 595          {
 596   1          weekday = ((month > 2 ? (year % 100) : (year % 100) - 1) + ((month > 2 ? (year % 100) : (year % 100) -
             - 1) / 4) + (year / 100) / 4 - 2 * (year / 100) + (26 * ((month > 2 ? month : month + 12) + 1) / 10) + day - 1) % 7;
 597   1      }
 598          
 599          // ºÏ≤È»’∆⁄≥Ã–Ú£¨∑µªÿ0±Ì æ»’∆⁄ŒﬁŒÛ£¨∑µªÿ1±Ì æ»’∆⁄”–ŒÛ
 600          bit CheckDate(unsigned int year, unsigned char month, unsigned char day)
 601          {
 602   1          if (month > 12 || month < 1)
 603   1              return 1; // ‘¬∑›”–ŒÛ
 604   1          if (day < 1)
 605   1              return 1; // »’∆⁄”–ŒÛ
 606   1          if (((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) && month == 2)
 607   1          {
 608   2              if (day > 29)
C51 COMPILER V9.01   CLOCK                                                                 09/18/2023 17:25:05 PAGE 11  

 609   2                  return 1; // »ÚƒÍ2‘¬29»’”–ŒÛ
 610   2          }
 611   1          else
 612   1          {
 613   2              if (day > Seg_Date[month - 1])
 614   2                  return 1;
 615   2          }
 616   1          return 0;
 617   1      }
 618          
 619          void Int0() interrupt 0
 620          {
 621   1          if (buttonDown == 0)
 622   1          {
 623   2              buttonDown = 1;
 624   2              button = 0;
 625   2          }
 626   1      }
 627          
 628          void Int1() interrupt 2
 629          {
 630   1          if (buttonDown == 0)
 631   1          {
 632   2              buttonDown = 1;
 633   2              button = 1;
 634   2          }
 635   1      }
 636          
 637          // ∂® ±∆˜0÷–∂œ∑˛ŒÒ∫Ø ˝
 638          void Timer0() interrupt 1
 639          {
 640   1          interruptCount++;
 641   1      
 642   1          TH0 = (65536 - INTERVAL * 1000) / 256;
 643   1          TL0 = (65536 - INTERVAL * 1000) % 256;
 644   1      
 645   1          if (interruptCount == (1000 / INTERVAL))
 646   1          { // 1√Î
 647   2              interruptCount = 0;
 648   2              SecondIncrease();
 649   2              if (hour == 0 && minute == 0 && second == 0)
 650   2              {
 651   3                  DateIncrease();
 652   3                  UpdateWeekday();
 653   3              }
 654   2          }
 655   1      
 656   1          if (buttonDown == 1)
 657   1          {
 658   2              Check();
 659   2          }
 660   1      
 661   1          if (shortOrLang == 1)
 662   1          {
 663   2              ShortPress();
 664   2          }
 665   1          else if (shortOrLang == 2)
 666   1          {
 667   2              LongPress();
 668   2          }
 669   1      
 670   1          if (mode == SHOW_TIME && alarm == 1)
C51 COMPILER V9.01   CLOCK                                                                 09/18/2023 17:25:05 PAGE 12  

 671   1          {
 672   2              if (hour == alarmHour && minute == alarmMinute && second == 00 && (alarmWeekday & (1 << weekday)) 
             -> 0 && interruptCount == 0)
 673   2                  alarmClockTimes = 2 * ALARMCLOCKTIMES;
 674   2              if (alarmClockTimes != 0)
 675   2              {
 676   3                  if ((0 < interruptCount && interruptCount < (250 / INTERVAL)) || ((500 / INTERVAL) < interrupt
             -Count && interruptCount < (750 / INTERVAL)))
 677   3                      Chime = !Chime;
 678   3                  else
 679   3                      Chime = 0;
 680   3                  if (interruptCount % (250 / INTERVAL) == 0)
 681   3                  {
 682   4                      alarmClockTimes--;
 683   4                      Chime = 0;
 684   4                  }
 685   3              }
 686   2          }
 687   1      
 688   1          if (mode == SHOW_TIME && hourlyChime == 1)
 689   1          {
 690   2              if (hourlyChimeTimes == 0 && minute == 0 && second == 0 && interruptCount == 0)
 691   2                  hourlyChimeTimes = 2 * (HOURLYCHIMETIMES + 1); // Œ““≤≤ª÷™µ¿’‚¿ÔŒ™ ≤√¥“™º”“ª£¨µ´ ¬ µæÕ «À¸ª·œÏ
             -HOURLYCHIMETIMES-1¥Œ£¨À˘“‘“™º”“ª≤π…œ°£
 692   2              if (hourlyChimeTimes != 0)
 693   2              {
 694   3                  if (interruptCount > (500 / INTERVAL))
 695   3                      Chime = !Chime;
 696   3                  else
 697   3                      Chime = 0;
 698   3                  if (interruptCount % (500 / INTERVAL) == 0)
 699   3                  {
 700   4                      hourlyChimeTimes--;
 701   4                      Chime = 0;
 702   4                  }
 703   3              }
 704   2          }
 705   1      
 706   1          switch (mode)
 707   1          {
 708   2          case SHOW_TIME:
 709   2              LED8[0] = hour / 10; // œ‘ æ–° ± ÆŒª
 710   2              LED8[1] = hour % 10; // œ‘ æ–° ±∏ˆŒª
 711   2              LED8[2] = 16;
 712   2              LED8[3] = minute / 10; // œ‘ æ∑÷÷” ÆŒª
 713   2              LED8[4] = minute % 10; // œ‘ æ∑÷÷”∏ˆŒª
 714   2              LED8[5] = 16;
 715   2              LED8[6] = second / 10; // œ‘ æ√Î ÆŒª
 716   2              LED8[7] = second % 10; // œ‘ æ√Î∏ˆŒª
 717   2              LED8Point = (1 << weekday) | (hourlyChime ? 0x80 : 0);
 718   2              Display(0xFF, 0xFF);
 719   2              break;
 720   2          case SHOW_DATE:
 721   2              LED8[0] = year / 1000;
 722   2              LED8[1] = year / 100 % 10;
 723   2              LED8[2] = year / 10 % 10;
 724   2              LED8[3] = year % 10;
 725   2              LED8[4] = month / 10;
 726   2              LED8[5] = month % 10;
 727   2              LED8[6] = day / 10;
 728   2              LED8[7] = day % 10;
 729   2              LED8Point = (1 << weekday) | (hourlyChime ? 0x80 : 0);
C51 COMPILER V9.01   CLOCK                                                                 09/18/2023 17:25:05 PAGE 13  

 730   2              Display(0xFF, 0xFF);
 731   2              break;
 732   2          case SET_HOUR:
 733   2              LED8Point = (1 << weekday) | (hourlyChime ? 0x80 : 0);
 734   2              if (interruptCount < (500 / INTERVAL))
 735   2                  Display(0xFF, 0xFF);
 736   2              else
 737   2                  Display(0xFC, 0xFF);
 738   2              break;
 739   2          case SET_MINUTE:
 740   2              LED8Point = (1 << weekday) | (hourlyChime ? 0x80 : 0);
 741   2              if (interruptCount < (500 / INTERVAL))
 742   2                  Display(0xFF, 0xFF);
 743   2              else
 744   2                  Display(0xE7, 0xFF);
 745   2              break;
 746   2          case SET_SECOND:
 747   2              LED8Point = (1 << weekday) | (hourlyChime ? 0x80 : 0);
 748   2              if (interruptCount < (500 / INTERVAL))
 749   2                  Display(0xFF, 0xFF);
 750   2              else
 751   2                  Display(0x3F, 0xFF);
 752   2              break;
 753   2          case SET_YEAR:
 754   2              LED8Point = (1 << weekday) | (hourlyChime ? 0x80 : 0);
 755   2              if (interruptCount < (500 / INTERVAL))
 756   2                  Display(0xFF, 0xFF);
 757   2              else
 758   2                  Display(0xF0, 0xFF);
 759   2              break;
 760   2          case SET_MONTH:
 761   2              LED8Point = (1 << weekday) | (hourlyChime ? 0x80 : 0);
 762   2              if (interruptCount < (500 / INTERVAL))
 763   2                  Display(0xFF, 0xFF);
 764   2              else
 765   2                  Display(0xCF, 0xFF);
 766   2              break;
 767   2          case SET_DAY:
 768   2              LED8Point = (1 << weekday) | (hourlyChime ? 0x80 : 0);
 769   2              if (interruptCount < (500 / INTERVAL))
 770   2                  Display(0xFF, 0xFF);
 771   2              else
 772   2                  Display(0x3F, 0xFF);
 773   2              break;
 774   2          case STOPWATCH:
 775   2              stopwatchMSecond = 0;
 776   2              stopwatchSecond = 0;
 777   2              stopwatchMinute = 0;
 778   2              LED8[0] = stopwatchMinute / 10; // œ‘ æ∑÷÷” ÆŒª
 779   2              LED8[1] = stopwatchMinute % 10; // œ‘ æ∑÷÷”∏ˆŒª
 780   2              LED8[2] = 16;
 781   2              LED8[3] = stopwatchSecond / 10; // œ‘ æ√Î ÆŒª
 782   2              LED8[4] = stopwatchSecond % 10; // œ‘ æ√Î∏ˆŒª
 783   2              LED8[5] = 16;
 784   2              LED8[6] = stopwatchMSecond / 100;
 785   2              LED8[7] = (stopwatchMSecond % 100) / 10;
 786   2      
 787   2              LED8Point = 0;
 788   2              Display(0xFF, 0xFF);
 789   2              break;
 790   2          case STOPWATCH_START:
 791   2              stopwatchMSecond += INTERVAL;
C51 COMPILER V9.01   CLOCK                                                                 09/18/2023 17:25:05 PAGE 14  

 792   2              if (stopwatchMSecond > 999)
 793   2              {
 794   3                  stopwatchMSecond = 0;
 795   3                  stopwatchSecond++;
 796   3              }
 797   2              if (stopwatchSecond > 59)
 798   2              {
 799   3                  stopwatchSecond = 0;
 800   3                  stopwatchMinute++;
 801   3              }
 802   2              if (stopwatchMinute > 59)
 803   2              {
 804   3                  stopwatchMinute = 0;
 805   3              }
 806   2      
 807   2              LED8[0] = stopwatchMinute / 10; // œ‘ æ∑÷÷” ÆŒª
 808   2              LED8[1] = stopwatchMinute % 10; // œ‘ æ∑÷÷”∏ˆŒª
 809   2              LED8[2] = 16;
 810   2              LED8[3] = stopwatchSecond / 10; // œ‘ æ√Î ÆŒª
 811   2              LED8[4] = stopwatchSecond % 10; // œ‘ æ√Î∏ˆŒª
 812   2              LED8[5] = 16;
 813   2              LED8[6] = stopwatchMSecond / 100;
 814   2              LED8[7] = (stopwatchMSecond % 100) / 10;
 815   2      
 816   2              LED8Point = 0;
 817   2              Display(0xFF, 0xFF);
 818   2              break;
 819   2          case STOPWATCH_PAUSE:
 820   2              LED8Point = 0;
 821   2              Display(0xFF, 0xFF);
 822   2              break;
 823   2          case ALARMCLOCK:
 824   2              LED8[3] = alarmHour / 10;
 825   2              LED8[4] = alarmHour % 10;
 826   2              LED8[5] = 16;
 827   2              LED8[6] = alarmMinute / 10;
 828   2              LED8[7] = alarmMinute % 10;
 829   2              if (alarm)
 830   2              {
 831   3                  LED8[0] = 17;
 832   3                  LED8[1] = 17;
 833   3                  LED8[2] = 17;
 834   3              }
 835   2              else
 836   2              {
 837   3                  LED8[0] = 0;
 838   3                  LED8[1] = 15;
 839   3                  LED8[2] = 15;
 840   3              }
 841   2              LED8Point = alarmWeekday;
 842   2              Display(0xFF, 0xFF);
 843   2              break;
 844   2          case ALARMCLOCK_HOUR:
 845   2              if (interruptCount < (500 / INTERVAL))
 846   2                  Display(0xFF, 0xFF);
 847   2              else
 848   2                  Display(0xE7, 0xFF);
 849   2              break;
 850   2          case ALARMCLOCK_MINUTE:
 851   2              if (interruptCount < (500 / INTERVAL))
 852   2                  Display(0xFF, 0xFF);
 853   2              else
C51 COMPILER V9.01   CLOCK                                                                 09/18/2023 17:25:05 PAGE 15  

 854   2                  Display(0x3F, 0xFF);
 855   2              break;
 856   2          case ALARMCLOCK_SUNDAY:
 857   2              if (interruptCount < (500 / INTERVAL))
 858   2                  Display(0xFF, 0xFF);
 859   2              else
 860   2                  Display(0xFF - (1 << 0), 0xFF);
 861   2              break;
 862   2          case ALARMCLOCK_MONDAY:
 863   2              if (interruptCount < (500 / INTERVAL))
 864   2                  Display(0xFF, 0xFF);
 865   2              else
 866   2                  Display(0xFF - (1 << 1), 0xFF);
 867   2              break;
 868   2          case ALARMCLOCK_TUESDAY:
 869   2              if (interruptCount < (500 / INTERVAL))
 870   2                  Display(0xFF, 0xFF);
 871   2              else
 872   2                  Display(0xFF - (1 << 2), 0xFF);
 873   2              break;
 874   2          case ALARMCLOCK_WEDNESDAY:
 875   2              if (interruptCount < (500 / INTERVAL))
 876   2                  Display(0xFF, 0xFF);
 877   2              else
 878   2                  Display(0xFF - (1 << 3), 0xFF);
 879   2              break;
 880   2          case ALARMCLOCK_THURSDAY:
 881   2              if (interruptCount < (500 / INTERVAL))
 882   2                  Display(0xFF, 0xFF);
 883   2              else
 884   2                  Display(0xFF - (1 << 4), 0xFF);
 885   2              break;
 886   2          case ALARMCLOCK_FRIDAY:
 887   2              if (interruptCount < (500 / INTERVAL))
 888   2                  Display(0xFF, 0xFF);
 889   2              else
 890   2                  Display(0xFF - (1 << 5), 0xFF);
 891   2              break;
 892   2          case ALARMCLOCK_SATURDAY:
 893   2              if (interruptCount < (500 / INTERVAL))
 894   2                  Display(0xFF, 0xFF);
 895   2              else
 896   2                  Display(0xFF - (1 << 6), 0xFF);
 897   2              break;
 898   2          default:
 899   2              break;
 900   2          }
 901   1      }
 902          
 903          void Display(unsigned char numEnable, unsigned char pointEnable)
 904          {
 905   1          unsigned char LED = Seg_Data[17];
 906   1      
 907   1          if (((numEnable >> displayIndex) & 1) == 1)
 908   1          {
 909   2              LED = Seg_Data[LED8[displayIndex]];
 910   2          }
 911   1      
 912   1          if (((pointEnable >> displayIndex) & 1) == 1 && ((LED8Point >> displayIndex) & 1) == 1)
 913   1          {
 914   2              LED = LED & 0x7F; // œ‘ æ–° ˝µ„
 915   2          }
C51 COMPILER V9.01   CLOCK                                                                 09/18/2023 17:25:05 PAGE 16  

 916   1      
 917   1          SEG_Send595OneByte(Seg_Addr[displayIndex]); // œ‘ æ‘⁄ƒƒ“ª∏ˆ ˝¬Îπ‹…œ
 918   1          SEG_Send595OneByte(LED);
 919   1      
 920   1          SEG_STCP = 0;
 921   1          SEG_STCP = 1; // STCP“˝Ω≈µƒ…œ…˝—ÿ∏¸–¬ ˝æ›
 922   1          SEG_STCP = 0;
 923   1      
 924   1          displayIndex++;
 925   1          displayIndex %= 8;
 926   1      }
 927          
 928          // œÚHC595∑¢ÀÕ“ª∏ˆ◊÷Ω⁄
 929          void SEG_Send595OneByte(unsigned char ucData)
 930          {
 931   1          unsigned char i;
 932   1      
 933   1          for (i = 0; i < 8; i++) // 8Œª ˝æ›“¿¥Œ–¥»Î£¨œ»–¥◊ÓµÕŒª
 934   1          {
 935   2              SEG_DS = (ucData & 0x80); // œ»∂¡»Î∏ﬂŒª   x&0x80;
 936   2              SEG_SHCP = 0;
 937   2              SEG_SHCP = 1;
 938   2              SEG_SHCP = 0; // SHCP“˝Ω≈µƒ…œ…˝—ÿ“∆»Î ˝æ›
 939   2              ucData <<= 1; //  ˝æ›◊Û“∆
 940   2          }
 941   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3365    ----
   CONSTANT SIZE    =     40    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     36       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
