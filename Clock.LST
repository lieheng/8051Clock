C51 COMPILER V9.01   CLOCK                                                                 09/21/2023 20:59:27 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE CLOCK
OBJECT MODULE PLACED IN Clock.OBJ
COMPILER INVOKED BY: D:\Software\Keil\C51\BIN\C51.EXE Clock.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <REG51.H>
   2          #include "LCD12864.h"
   3          
   4          #include <string.h>
   5          
   6          #define INTERVAL 10 // 间隔10毫秒
   7          
   8          #define INIT_HOUR 23   // 初始化小时
   9          #define INIT_MINUTE 59 // 初始化分钟
  10          #define INIT_SECOND 58 // 初始化秒
  11          
  12          #define INIT_YEAR 2023 // 初始化年
  13          #define INIT_MONTH 9   // 初始化月
  14          #define INIT_DAY 19    // 初始化日
  15          
  16          #define INIT_ALARM 0         // 初始化闹钟功能，1表示响，0表示不响
  17          #define INIT_ALARM_HOUR 23   // 初始化闹钟小时
  18          #define INIT_ALARM_MINUTE 59 // 初始化闹钟分钟
  19          #define INIT_ALARM_WEEKDAY 0 // 初始化闹钟星期
  20          #define ALARMCLOCKTIMES 6    // 闹钟响铃次数
  21          
  22          #define INIT_HOURLY_CHIME 0 // 初始化整点报时功能，1表示开，0表示关
  23          #define HOURLYCHIMETIMES 3  // 整点响铃次数
  24          
  25          unsigned char xdata hour = INIT_HOUR;     // 初始化小时
  26          unsigned char xdata minute = INIT_MINUTE; // 初始化分钟
  27          unsigned char xdata second = INIT_SECOND; // 初始化秒
  28          
  29          unsigned int xdata year = INIT_YEAR;    // 初始化年
  30          unsigned char xdata month = INIT_MONTH; // 初始化月
  31          unsigned char xdata day = INIT_DAY;     // 初始化日
  32          
  33          unsigned char xdata weekday = 0; // 星期，星期初始化任务由init()函数负责
  34          
  35          unsigned char alarmHour = INIT_ALARM_HOUR;       // 闹钟时
  36          unsigned char alarmMinute = INIT_ALARM_MINUTE;   // 闹钟分
  37          unsigned char alarmWeekday = INIT_ALARM_WEEKDAY; // 闹钟星期功能，低0位为1表示周日响，低1位为1表示周一响，
             -以此类推
  38          
  39          bit alarm = INIT_ALARM; // 闹钟功能，1表示响，0表示不响
  40          
  41          bit hourlyChime = INIT_HOURLY_CHIME; // 整点报时功能，1表示开，0表示关
  42          
  43          bit buttonDown = 0;            // 用于判断是否有按键按下，1为有，0为无
  44          bit button = 0;                // 用于判断按下的是哪个按键
  45          unsigned int checkCount = 0;   // 用于检查按键是长按还是短按，每按一毫秒该变量加一
  46          unsigned char shortOrLang = 0; // 用于表示按键是长按还是短按的标志，0表示无效，1表示短按，2表示长按
  47          
  48          unsigned char line1[17] = "                ";
  49          unsigned char line2[17] = "                ";
  50          unsigned char line3[17] = "                ";
  51          unsigned char line4[17] = "                ";
  52          
  53          unsigned char hourlyChimeTimes = 0; // 记录整点报时的响铃次数
  54          unsigned char alarmClockTimes = 0;  // 记录闹钟的响铃次数
C51 COMPILER V9.01   CLOCK                                                                 09/21/2023 20:59:27 PAGE 2   

  55          
  56          unsigned int stopwatchMSecond = 0; // 秒表的毫秒数
  57          unsigned char stopwatchSecond = 0; // 秒表的秒数
  58          unsigned char stopwatchMinute = 0; // 秒表的分钟数
  59          unsigned int recordNum = 0;        // 记录次数
  60          
  61          unsigned char xdata setAlarmHour = INIT_ALARM_HOUR;       // 设置闹钟时的变量
  62          unsigned char xdata setAlarmMinute = INIT_ALARM_MINUTE;   // 设置闹钟分的变量
  63          unsigned char xdata setAlarmWeekday = INIT_ALARM_WEEKDAY; // 设置闹钟星期的变量，低0位为1表示周日响，低1位
             -为1表示周一响，以此类推
  64          
  65          unsigned char xdata setHour = INIT_HOUR;     // 设置小时的变量
  66          unsigned char xdata setMinute = INIT_MINUTE; // 设置分钟的变量
  67          unsigned char xdata setSecond = INIT_SECOND; // 设置秒的变量
  68          
  69          enum MODE
  70          {
  71              SHOW,                 // 显示模式
  72              SET_YEAR,             // 设置年模式
  73              SET_MONTH,            // 设置月模式
  74              SET_DAY,              // 设置日模式
  75              SET_HOUR,             // 设置时模式
  76              SET_MINUTE,           // 设置分模式
  77              SET_SECOND,           // 设置秒模式
  78              STOPWATCH,            // 秒表模式
  79              STOPWATCH_START,      // 秒表计时模式
  80              STOPWATCH_PAUSE,      // 秒表暂停模式
  81              ALARMCLOCK,           // 闹钟模式
  82              ALARMCLOCK_HOUR,      // 设置闹钟时模式
  83              ALARMCLOCK_MINUTE,    // 设置闹钟分模式
  84              ALARMCLOCK_SUNDAY,    // 设置闹钟周日模式
  85              ALARMCLOCK_MONDAY,    // 设置闹钟周一模式
  86              ALARMCLOCK_TUESDAY,   // 设置闹钟周二模式
  87              ALARMCLOCK_WEDNESDAY, // 设置闹钟周三模式
  88              ALARMCLOCK_THURSDAY,  // 设置闹钟周四模式
  89              ALARMCLOCK_FRIDAY,    // 设置闹钟周五模式
  90              ALARMCLOCK_SATURDAY   // 设置闹钟周六模式
  91          };
  92          
  93          unsigned char mode = SHOW; // 模式
  94          
  95          unsigned int interruptCount = 0; // 中断次数
  96          
  97          sbit Chime = P2 ^ 2; // 蜂鸣器
  98          
  99          sbit P3_2 = P3 ^ 2; // 外部中断0的控制引脚
 100          sbit P3_3 = P3 ^ 3; // 外部中断1的控制引脚
 101          
 102          unsigned char code Seg_Date[] = {
 103              31, // 1月
 104              28, // 2月
 105              31, // 3月
 106              30, // 4月
 107              31, // 5月
 108              30, // 6月
 109              31, // 7月
 110              31, // 8月
 111              30, // 9月
 112              31, // 10月
 113              30, // 11月
 114              31  // 12月
 115          };
C51 COMPILER V9.01   CLOCK                                                                 09/21/2023 20:59:27 PAGE 3   

 116          
 117          // 初始化函数
 118          void Init();
 119          // 切换模式
 120          void ChangeMode(MODE);
 121          // 检查当前按键是长按还是短按
 122          void Check();
 123          // 按键短按处理程序
 124          void ShortPress();
 125          // 按键长按处理程序
 126          void LongPress();
 127          // 秒数增加处理程序
 128          void SecondIncrease();
 129          // 日期增加处理程序
 130          void DateIncrease();
 131          // 更新日期
 132          void UpdateWeekday();
 133          // 清空字符串
 134          void ClearChar(unsigned char *str);
 135          // 检查日期程序，返回0表示日期无误，返回1表示日期有误
 136          bit CheckDate(unsigned int year, unsigned char month, unsigned char day);
 137          
 138          void main()
 139          {
 140   1          Init();
 141   1          while (1)
 142   1          {
 143   2              ;
 144   2          }
 145   1      }
 146          
 147          // 初始化函数
 148          void Init()
 149          {
 150   1      
 151   1          LCD12864_Init(); // 初始化液晶屏
 152   1      
 153   1          UpdateWeekday(); // 初始化星期
 154   1      
 155   1          ChangeMode(SHOW);
 156   1      
 157   1          Chime = 0; // 初始化蜂鸣器引脚为0，防止损坏蜂鸣器
 158   1      
 159   1          EA = 1;      // 开启总中断
 160   1          IT0 = 1;     // 设置外部中断0为边沿触发方式
 161   1          EX0 = 1;     // 允许外部中断0
 162   1          IT1 = 1;     // 设置外部中断1为边沿触发方式
 163   1          EX1 = 1;     // 允许外部中断1
 164   1          PT0 = 1;     // 计时器0中断优先级为最高
 165   1          TMOD = 0x01; // 设置计时器0工作在方式1
 166   1          ET0 = 1;     // 允许计时器0中断
 167   1          TR0 = 1;     // 启动计时器
 168   1      
 169   1          TH0 = (65536 - INTERVAL * 1000) / 256;
 170   1          TL0 = (65536 - INTERVAL * 1000) % 256;
 171   1      }
 172          
 173          void ChangeMode(MODE)
 174          {
 175   1          mode = MODE;
 176   1          switch (mode)
 177   1          {
C51 COMPILER V9.01   CLOCK                                                                 09/21/2023 20:59:27 PAGE 4   

 178   2          case SHOW:
 179   2              ClearChar(line1);
 180   2              ClearChar(line2);
 181   2              ClearChar(line3);
 182   2              ClearChar(line4);
 183   2      
 184   2              line1[4] = hour / 10 + '0'; // 小时十位
 185   2              line1[5] = hour % 10 + '0'; // 小时个位
 186   2              line1[6] = ':';
 187   2              line1[7] = minute / 10 + '0'; // 分钟十位
 188   2              line1[8] = minute % 10 + '0'; // 分钟个位
 189   2              line1[9] = ':';
 190   2              line1[10] = second / 10 + '0'; // 秒钟十位
 191   2              line1[11] = second % 10 + '0'; // 秒钟个位
 192   2      
 193   2              line2[3] = year / 1000 + '0';     // 年份千位
 194   2              line2[4] = year / 100 % 10 + '0'; // 年份百位
 195   2              line2[5] = year / 10 % 10 + '0';  // 年份十位
 196   2              line2[6] = year % 10 + '0';       // 年份个位
 197   2              line2[7] = '-';
 198   2              line2[8] = month / 10 + '0'; // 月份十位
 199   2              line2[9] = month % 10 + '0'; // 月份个位
 200   2              line2[10] = '-';
 201   2              line2[11] = day / 10 + '0'; // 日期十位
 202   2              line2[12] = day % 10 + '0'; // 日期个位
 203   2      
 204   2              switch (weekday)
 205   2              {
 206   3              case 0:
 207   3                  strncpy(line3 + 6, "周日", 4);
 208   3                  break;
 209   3              case 1:
 210   3                  strncpy(line3 + 6, "周一", 4);
 211   3                  break;
 212   3              case 2:
 213   3                  strncpy(line3 + 6, "周二", 4);
 214   3                  break;
 215   3              case 3:
 216   3                  strncpy(line3 + 6, "周 3", 4);
 217   3                  break;
 218   3              case 4:
 219   3                  strncpy(line3 + 6, "周四", 4);
 220   3                  break;
 221   3              case 5:
 222   3                  strncpy(line3 + 6, "周五", 4);
 223   3                  break;
 224   3              case 6:
 225   3                  strncpy(line3 + 6, "周六", 4);
 226   3                  break;
 227   3              default:
 228   3                  break;
 229   3              }
 230   2      
 231   2              strncpy(line4 + 2, "整点报时  ", 10);
 232   2              if (hourlyChime)
 233   2                  strncpy(line4 + 12, "开", 2);
 234   2              else
 235   2                  strncpy(line4 + 12, "关", 2);
 236   2      
 237   2              LCD12864_DisplayOneLine(LINE1, line1, 16);
 238   2              LCD12864_DisplayOneLine(LINE2, line2, 16);
 239   2              LCD12864_DisplayOneLine(LINE3, line3, 16);
C51 COMPILER V9.01   CLOCK                                                                 09/21/2023 20:59:27 PAGE 5   

 240   2              LCD12864_DisplayOneLine(LINE4, line4, 16);
 241   2              break;
 242   2          case STOPWATCH:
 243   2              recordNum = 0;
 244   2              ClearChar(line1);
 245   2              ClearChar(line2);
 246   2              ClearChar(line3);
 247   2              ClearChar(line4);
 248   2      
 249   2              stopwatchMinute = 0;
 250   2              stopwatchSecond = 0;
 251   2              stopwatchMSecond = 0;
 252   2      
 253   2              line1[4] = stopwatchMinute / 10 + '0'; // 分钟十位
 254   2              line1[5] = stopwatchMinute % 10 + '0'; // 分钟个位
 255   2              line1[6] = ':';
 256   2              line1[7] = stopwatchSecond / 10 + '0'; // 秒十位
 257   2              line1[8] = stopwatchSecond % 10 + '0'; // 秒个位
 258   2              line1[9] = ':';
 259   2              line1[10] = stopwatchMSecond / 100 + '0';     // 毫秒百位
 260   2              line1[11] = stopwatchMSecond / 10 % 10 + '0'; // 毫秒十位
 261   2      
 262   2              LCD12864_DisplayOneLine(LINE1, line1, 16);
 263   2              LCD12864_DisplayOneLine(LINE2, line2, 16);
 264   2              LCD12864_DisplayOneLine(LINE3, line3, 16);
 265   2              LCD12864_DisplayOneLine(LINE4, line4, 16);
 266   2      
 267   2              break;
 268   2          default:
 269   2              break;
 270   2          }
 271   1      }
 272          
 273          // 检查当前按键是长按还是短按
 274          void Check()
 275          {
 276   1          checkCount++; // 按键时间计数，每过一毫秒加一。
 277   1      
 278   1          if (checkCount < 10 / INTERVAL) // 10ms延迟去抖动
 279   1              return;
 280   1      
 281   1          if (checkCount > 1010 / INTERVAL) // 如果按下时间大于一秒，为长按。
 282   1          {
 283   2              shortOrLang = 2;
 284   2              checkCount = 0;
 285   2              buttonDown = 0;
 286   2          }
 287   1          else // 如果按下时间小于一秒，则判断是否松开，若松开，则为短按，否则继续计数。
 288   1          {
 289   2              if ((button == 0 && P3_2 == 1) || (button == 1 && P3_3 == 1))
 290   2              {
 291   3                  shortOrLang = 1;
 292   3                  checkCount = 0;
 293   3                  buttonDown = 0;
 294   3              }
 295   2          }
 296   1      }
 297          
 298          // 按键短按处理程序
 299          void ShortPress()
 300          {
 301   1          if (button == 0) // 如果按的是键A
C51 COMPILER V9.01   CLOCK                                                                 09/21/2023 20:59:27 PAGE 6   

 302   1          {
 303   2              switch (mode)
 304   2              {
 305   3              case SHOW:
 306   3                  ChangeMode(STOPWATCH);
 307   3                  break;
 308   3              case STOPWATCH:
 309   3                  mode = ALARMCLOCK;
 310   3                  break;
 311   3              case STOPWATCH_START:
 312   3              case STOPWATCH_PAUSE:
 313   3                  recordNum++;
 314   3                  if (recordNum % 3 == 1)
 315   3                  {
 316   4      
 317   4                      ClearChar(line2);
 318   4                      line2[0] = (recordNum % 1000) / 100 + '0';
 319   4                      line2[1] = (recordNum % 100) / 10 + '0';
 320   4                      line2[2] = (recordNum % 10) + '0';
 321   4                      line2[4] = stopwatchMinute / 10 + '0'; // 分钟十位
 322   4                      line2[5] = stopwatchMinute % 10 + '0'; // 分钟个位
 323   4                      line2[6] = ':';
 324   4                      line2[7] = stopwatchSecond / 10 + '0'; // 秒十位
 325   4                      line2[8] = stopwatchSecond % 10 + '0'; // 秒个位
 326   4                      line2[9] = ':';
 327   4                      line2[10] = stopwatchMSecond / 100 + '0';     // 毫秒百位
 328   4                      line2[11] = stopwatchMSecond / 10 % 10 + '0'; // 毫秒十位
 329   4      
 330   4                      LCD12864_DisplayOneLine(LINE2, line2, 16);
 331   4                  }
 332   3                  else if (recordNum % 3 == 2)
 333   3                  {
 334   4                      ClearChar(line3);
 335   4                      line3[0] = (recordNum % 1000) / 100 + '0';
 336   4                      line3[1] = (recordNum % 100) / 10 + '0';
 337   4                      line3[2] = (recordNum % 10) + '0';
 338   4                      line3[4] = stopwatchMinute / 10 + '0'; // 分钟十位
 339   4                      line3[5] = stopwatchMinute % 10 + '0'; // 分钟个位
 340   4                      line3[6] = ':';
 341   4                      line3[7] = stopwatchSecond / 10 + '0'; // 秒十位
 342   4                      line3[8] = stopwatchSecond % 10 + '0'; // 秒个位
 343   4                      line3[9] = ':';
 344   4                      line3[10] = stopwatchMSecond / 100 + '0';     // 毫秒百位
 345   4                      line3[11] = stopwatchMSecond / 10 % 10 + '0'; // 毫秒十位
 346   4                      LCD12864_DisplayOneLine(LINE3, line3, 16);
 347   4                  }
 348   3                  else
 349   3                  {
 350   4                      ClearChar(line4);
 351   4                      line4[0] = (recordNum % 1000) / 100 + '0';
 352   4                      line4[1] = (recordNum % 100) / 10 + '0';
 353   4                      line4[2] = (recordNum % 10) + '0';
 354   4                      line4[4] = stopwatchMinute / 10 + '0'; // 分钟十位
 355   4                      line4[5] = stopwatchMinute % 10 + '0'; // 分钟个位
 356   4                      line4[6] = ':';
 357   4                      line4[7] = stopwatchSecond / 10 + '0'; // 秒十位
 358   4                      line4[8] = stopwatchSecond % 10 + '0'; // 秒个位
 359   4                      line4[9] = ':';
 360   4                      line4[10] = stopwatchMSecond / 100 + '0';     // 毫秒百位
 361   4                      line4[11] = stopwatchMSecond / 10 % 10 + '0'; // 毫秒十位
 362   4                      LCD12864_DisplayOneLine(LINE4, line4, 16);
 363   4                  }
C51 COMPILER V9.01   CLOCK                                                                 09/21/2023 20:59:27 PAGE 7   

 364   3      
 365   3                  break;
 366   3              case ALARMCLOCK:
 367   3                  ChangeMode(SHOW);
 368   3                  break;
 369   3              case SET_HOUR:
 370   3                  line1[4] = setHour / 10 + '0';
 371   3                  line1[5] = setHour % 10 + '0';
 372   3                  ChangeMode(SET_MINUTE);
 373   3                  break;
 374   3              case SET_MINUTE:
 375   3                  line1[7] = setMinute / 10 + '0';
 376   3                  line1[8] = setMinute % 10 + '0';
 377   3                  ChangeMode(SET_SECOND);
 378   3                  break;
 379   3              case SET_SECOND:
 380   3                  line1[10] = setSecond / 10 + '0';
 381   3                  line1[11] = setSecond % 10 + '0';
 382   3                  ChangeMode(SET_HOUR);
 383   3                  break;
 384   3              case SET_YEAR:
 385   3                  line2[3] = year / 1000 + '0';     // 年份千位
 386   3                  line2[4] = year / 100 % 10 + '0'; // 年份百位
 387   3                  line2[5] = year / 10 % 10 + '0';  // 年份十位
 388   3                  line2[6] = year % 10 + '0';       // 年份个位
 389   3                  ChangeMode(SET_MONTH);
 390   3                  break;
 391   3              case SET_MONTH:
 392   3                  line2[8] = month / 10 + '0'; // 月份十位
 393   3                  line2[9] = month % 10 + '0'; // 月份个位
 394   3                  ChangeMode(SET_DAY);
 395   3                  break;
 396   3              case SET_DAY:
 397   3                  line2[11] = day / 10 + '0'; // 日期十位
 398   3                  line2[12] = day % 10 + '0'; // 日期个位
 399   3                  ChangeMode(SET_YEAR);
 400   3                  break;
 401   3              case ALARMCLOCK_HOUR:
 402   3                  mode = ALARMCLOCK_MINUTE;
 403   3                  break;
 404   3              case ALARMCLOCK_MINUTE:
 405   3                  mode = ALARMCLOCK_SUNDAY;
 406   3                  break;
 407   3              case ALARMCLOCK_SUNDAY:
 408   3                  mode = ALARMCLOCK_MONDAY;
 409   3                  break;
 410   3              case ALARMCLOCK_MONDAY:
 411   3                  mode = ALARMCLOCK_TUESDAY;
 412   3                  break;
 413   3              case ALARMCLOCK_TUESDAY:
 414   3                  mode = ALARMCLOCK_WEDNESDAY;
 415   3                  break;
 416   3              case ALARMCLOCK_WEDNESDAY:
 417   3                  mode = ALARMCLOCK_THURSDAY;
 418   3                  break;
 419   3              case ALARMCLOCK_THURSDAY:
 420   3                  mode = ALARMCLOCK_FRIDAY;
 421   3                  break;
 422   3              case ALARMCLOCK_FRIDAY:
 423   3                  mode = ALARMCLOCK_SATURDAY;
 424   3                  break;
 425   3              case ALARMCLOCK_SATURDAY:
C51 COMPILER V9.01   CLOCK                                                                 09/21/2023 20:59:27 PAGE 8   

 426   3                  mode = ALARMCLOCK_HOUR;
 427   3                  break;
 428   3              default:
 429   3                  break;
 430   3              }
 431   2          }
 432   1          else
 433   1          {
 434   2              switch (mode)
 435   2              {
 436   3              case SHOW:
 437   3                  hourlyChime = !hourlyChime;
 438   3                  strncpy(line4 + 2, "整点报时  ", 10);
 439   3                  if (hourlyChime)
 440   3                      strncpy(line4 + 12, "开", 2);
 441   3                  else
 442   3                      strncpy(line4 + 12, "关", 2);
 443   3                  LCD12864_DisplayOneLine(LINE4, line4, 16);
 444   3                  break;
 445   3              case SET_YEAR:
 446   3                  year++;
 447   3                  year %= 10000;
 448   3      
 449   3                  UpdateWeekday();
 450   3                  break;
 451   3              case SET_MONTH:
 452   3                  month = (month % 12) + 1;
 453   3      
 454   3                  UpdateWeekday();
 455   3                  break;
 456   3              case SET_DAY:
 457   3                  if (((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) && month == 2) // 闰年2月
 458   3                      day = (day % 29) + 1;
 459   3                  else
 460   3                      day = (day % Seg_Date[month - 1]) + 1;
 461   3      
 462   3                  UpdateWeekday();
 463   3                  break;
 464   3              case SET_HOUR:
 465   3                  setHour++;
 466   3                  setHour %= 24;
 467   3      
 468   3                  break;
 469   3              case SET_MINUTE:
 470   3                  setMinute++;
 471   3                  setMinute %= 60;
 472   3      
 473   3                  break;
 474   3              case SET_SECOND:
 475   3                  setSecond++;
 476   3                  setSecond %= 60;
 477   3      
 478   3                  break;
 479   3              case STOPWATCH:
 480   3                  ChangeMode(STOPWATCH_START);
 481   3                  break;
 482   3              case STOPWATCH_START:
 483   3                  ChangeMode(STOPWATCH_PAUSE);
 484   3                  break;
 485   3              case STOPWATCH_PAUSE:
 486   3                  ChangeMode(STOPWATCH_START);
 487   3                  break;
C51 COMPILER V9.01   CLOCK                                                                 09/21/2023 20:59:27 PAGE 9   

 488   3              case ALARMCLOCK:
 489   3                  alarm = !alarm;
 490   3                  break;
 491   3              case ALARMCLOCK_HOUR:
 492   3                  setAlarmHour++;
 493   3                  setAlarmHour %= 24;
 494   3      
 495   3                  break;
 496   3              case ALARMCLOCK_MINUTE:
 497   3                  setAlarmMinute++;
 498   3                  setAlarmMinute %= 60;
 499   3      
 500   3                  break;
 501   3              case ALARMCLOCK_SUNDAY:
 502   3      
 503   3                  setAlarmWeekday = setAlarmWeekday ^ (1 << 0); // 低0位取反
 504   3      
 505   3                  break;
 506   3              case ALARMCLOCK_MONDAY:
 507   3      
 508   3                  setAlarmWeekday = setAlarmWeekday ^ (1 << 1); // 低1位取反
 509   3      
 510   3                  break;
 511   3              case ALARMCLOCK_TUESDAY:
 512   3      
 513   3                  setAlarmWeekday = setAlarmWeekday ^ (1 << 2); // 低2位取反
 514   3      
 515   3                  break;
 516   3              case ALARMCLOCK_WEDNESDAY:;
 517   3                  setAlarmWeekday = setAlarmWeekday ^ (1 << 3); // 低3位取反
 518   3      
 519   3                  break;
 520   3              case ALARMCLOCK_THURSDAY:
 521   3      
 522   3                  setAlarmWeekday = setAlarmWeekday ^ (1 << 4); // 低4位取反
 523   3      
 524   3                  break;
 525   3              case ALARMCLOCK_FRIDAY:
 526   3      
 527   3                  setAlarmWeekday = setAlarmWeekday ^ (1 << 5); // 低5位取反
 528   3      
 529   3                  break;
 530   3              case ALARMCLOCK_SATURDAY:
 531   3      
 532   3                  setAlarmWeekday = setAlarmWeekday ^ (1 << 6); // 低6位取反
 533   3      
 534   3                  break;
 535   3              default:
 536   3                  break;
 537   3              }
 538   2          }
 539   1      
 540   1          shortOrLang = 0; // 重置按键标志
 541   1      }
 542          
 543          // 按键长按处理程序
 544          void LongPress()
 545          {
 546   1          if (button == 0) // 如果按的是键A
 547   1          {
 548   2              switch (mode)
 549   2              {
C51 COMPILER V9.01   CLOCK                                                                 09/21/2023 20:59:27 PAGE 10  

 550   3              case SHOW:
 551   3                  setHour = hour;
 552   3                  setMinute = minute;
 553   3                  setSecond = second;
 554   3                  ChangeMode(SET_HOUR);
 555   3                  break;
 556   3              case SET_YEAR:
 557   3              case SET_MONTH:
 558   3              case SET_DAY:
 559   3                  if (!CheckDate(year, month, day)) // 如果日期无误才能确定
 560   3                  {
 561   4                      ChangeMode(SHOW);
 562   4                  }
 563   3                  break;
 564   3              case SET_HOUR:
 565   3              case SET_MINUTE:
 566   3              case SET_SECOND:
 567   3                  hour = setHour;
 568   3                  minute = setMinute;
 569   3                  second = setSecond;
 570   3                  ChangeMode(SHOW);
 571   3                  break;
 572   3              case ALARMCLOCK:
 573   3                  mode = ALARMCLOCK_HOUR;
 574   3                  break;
 575   3              case ALARMCLOCK_HOUR:
 576   3              case ALARMCLOCK_MINUTE:
 577   3              case ALARMCLOCK_SUNDAY:
 578   3              case ALARMCLOCK_MONDAY:
 579   3              case ALARMCLOCK_TUESDAY:
 580   3              case ALARMCLOCK_WEDNESDAY:
 581   3              case ALARMCLOCK_THURSDAY:
 582   3              case ALARMCLOCK_FRIDAY:
 583   3              case ALARMCLOCK_SATURDAY:
 584   3                  alarmHour = setAlarmHour;
 585   3                  alarmMinute = setAlarmMinute;
 586   3                  alarmWeekday = setAlarmWeekday;
 587   3                  mode = ALARMCLOCK;
 588   3                  break;
 589   3              default:
 590   3                  break;
 591   3              }
 592   2          }
 593   1          else
 594   1          {
 595   2              switch (mode)
 596   2              {
 597   3              case SHOW:
 598   3                  ChangeMode(SET_YEAR);
 599   3                  break;
 600   3              case SET_HOUR:
 601   3              case SET_MINUTE:
 602   3              case SET_SECOND:
 603   3                  ChangeMode(SHOW);
 604   3                  break;
 605   3              case SET_YEAR:
 606   3                  year--;
 607   3                  year %= 10000;
 608   3      
 609   3                  UpdateWeekday();
 610   3                  break;
 611   3              case SET_MONTH:
C51 COMPILER V9.01   CLOCK                                                                 09/21/2023 20:59:27 PAGE 11  

 612   3                  month += 10;
 613   3                  month = (month % 12) + 1;
 614   3      
 615   3                  UpdateWeekday();
 616   3                  break;
 617   3              case SET_DAY:
 618   3                  if (((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) && month == 2)
 619   3                  {
 620   4                      day += 29 - 2;
 621   4                      day = (day % 29) + 1;
 622   4                  }
 623   3                  else
 624   3                  {
 625   4                      day += Seg_Date[month - 1] - 2;
 626   4                      day = (day % Seg_Date[month - 1]) + 1;
 627   4                  }
 628   3      
 629   3                  UpdateWeekday();
 630   3                  break;
 631   3              case STOPWATCH_PAUSE:
 632   3                  ChangeMode(STOPWATCH);
 633   3                  break;
 634   3              case ALARMCLOCK_HOUR:
 635   3              case ALARMCLOCK_MINUTE:
 636   3              case ALARMCLOCK_SUNDAY:
 637   3              case ALARMCLOCK_MONDAY:
 638   3              case ALARMCLOCK_TUESDAY:
 639   3              case ALARMCLOCK_WEDNESDAY:
 640   3              case ALARMCLOCK_THURSDAY:
 641   3              case ALARMCLOCK_FRIDAY:
 642   3              case ALARMCLOCK_SATURDAY:
 643   3                  setAlarmHour = alarmHour;
 644   3                  setAlarmMinute = alarmMinute;
 645   3                  setAlarmWeekday = alarmWeekday;
 646   3                  mode = ALARMCLOCK;
 647   3                  break;
 648   3              default:
 649   3                  break;
 650   3              }
 651   2          }
 652   1      
 653   1          shortOrLang = 0; // 重置按键标志
 654   1      }
 655          
 656          // 秒数增加处理程序
 657          void SecondIncrease()
 658          {
 659   1          second++;
 660   1          if (second > 59)
 661   1          {
 662   2              second = 0;
 663   2              minute++;
 664   2          }
 665   1      
 666   1          if (minute > 59)
 667   1          {
 668   2              minute = 0;
 669   2              hour++;
 670   2          }
 671   1      
 672   1          if (hour > 23)
 673   1          {
C51 COMPILER V9.01   CLOCK                                                                 09/21/2023 20:59:27 PAGE 12  

 674   2              hour = 0;
 675   2          }
 676   1      }
 677          
 678          // 日期增加处理程序
 679          void DateIncrease()
 680          {
 681   1          day++;
 682   1          if (CheckDate(year, month, day))
 683   1          {
 684   2              day = 1;
 685   2              month++;
 686   2              if (month > 12)
 687   2              {
 688   3                  month = 1;
 689   3                  year++;
 690   3              }
 691   2          }
 692   1      }
 693          
 694          // 更新日期
 695          void UpdateWeekday()
 696          {
 697   1          weekday = (month > 2 ? (year % 100) : (year % 100) - 1) + ((month > 2 ? (year % 100) : (year % 100) - 
             -1) / 4) + (year / 100) / 4 - 2 * (year / 100) + (26 * ((month > 2 ? month : month + 12) + 1) / 10) + day - 1;
 698   1          while (weekday < 0)
 699   1          {
 700   2              weekday += 7;
 701   2          }
 702   1          weekday %= 7;
 703   1          ClearChar(line3);
 704   1      
 705   1          switch (weekday)
 706   1          {
 707   2          case 0:
 708   2              strncpy(line3 + 6, "周日", 4);
 709   2              break;
 710   2          case 1:
 711   2              strncpy(line3 + 6, "周一", 4);
 712   2              break;
 713   2          case 2:
 714   2              strncpy(line3 + 6, "周二", 4);
 715   2              break;
 716   2          case 3:
 717   2              strncpy(line3 + 6, "周 3", 4);
 718   2              break;
 719   2          case 4:
 720   2              strncpy(line3 + 6, "周四", 4);
 721   2              break;
 722   2          case 5:
 723   2              strncpy(line3 + 6, "周五", 4);
 724   2              break;
 725   2          case 6:
 726   2              strncpy(line3 + 6, "周六", 4);
 727   2              break;
 728   2          default:
 729   2              break;
 730   2          }
 731   1      
 732   1          LCD12864_DisplayOneLine(LINE3, line3, 16);
 733   1      }
 734          
C51 COMPILER V9.01   CLOCK                                                                 09/21/2023 20:59:27 PAGE 13  

 735          // 检查日期程序，返回0表示日期无误，返回1表示日期有误
 736          bit CheckDate(unsigned int year, unsigned char month, unsigned char day)
 737          {
 738   1          if (month > 12 || month < 1)
 739   1              return 1; // 月份有误
 740   1      
 741   1          if (day < 1)
 742   1              return 1; // 日期有误
 743   1      
 744   1          if (((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) && month == 2)
 745   1          {
 746   2              if (day > 29)
 747   2                  return 1; // 闰年2月29日有误
 748   2          }
 749   1          else
 750   1          {
 751   2              if (day > Seg_Date[month - 1])
 752   2                  return 1;
 753   2          }
 754   1      
 755   1          return 0;
 756   1      }
 757          
 758          void ClearChar(unsigned char *str)
 759          {
 760   1          unsigned char len = strlen(str);
 761   1          unsigned char i = 0;
 762   1          for (i = 0; i < len; i++)
 763   1          {
 764   2              str[i] = ' ';
 765   2          }
 766   1      }
 767          
 768          void Int0() interrupt 0
 769          {
 770   1          if (buttonDown == 0)
 771   1          {
 772   2              buttonDown = 1;
 773   2              button = 0;
 774   2          }
 775   1      }
 776          
 777          void Int1() interrupt 2
 778          {
 779   1          if (buttonDown == 0)
 780   1          {
 781   2              buttonDown = 1;
 782   2              button = 1;
 783   2          }
 784   1      }
 785          
 786          // 定时器0中断服务函数
 787          void Timer0() interrupt 1
 788          {
 789   1          interruptCount++;
 790   1      
 791   1          TH0 = (65536 - INTERVAL * 1000) / 256;
 792   1          TL0 = (65536 - INTERVAL * 1000) % 256;
 793   1      
 794   1          if (interruptCount == (1000 / INTERVAL))
 795   1          { // 1秒
 796   2              interruptCount = 0;
C51 COMPILER V9.01   CLOCK                                                                 09/21/2023 20:59:27 PAGE 14  

 797   2              SecondIncrease();
 798   2              if (mode == SHOW)
 799   2              {
 800   3                  ClearChar(line1);
 801   3      
 802   3                  line1[4] = hour / 10 + '0'; // 小时十位
 803   3                  line1[5] = hour % 10 + '0'; // 小时个位
 804   3                  line1[6] = ':';
 805   3                  line1[7] = minute / 10 + '0'; // 分钟十位
 806   3                  line1[8] = minute % 10 + '0'; // 分钟个位
 807   3                  line1[9] = ':';
 808   3                  line1[10] = second / 10 + '0'; // 秒钟十位
 809   3                  line1[11] = second % 10 + '0'; // 秒钟个位
 810   3      
 811   3                  LCD12864_DisplayOneLine(LINE1, line1, 16);
 812   3              }
 813   2              if (hour == 0 && minute == 0 && second == 0)
 814   2              {
 815   3                  DateIncrease();
 816   3                  UpdateWeekday();
 817   3                  if (mode == SHOW)
 818   3                  {
 819   4                      ClearChar(line2);
 820   4      
 821   4                      line2[3] = year / 1000 + '0';     // 年份千位
 822   4                      line2[4] = year / 100 % 10 + '0'; // 年份百位
 823   4                      line2[5] = year / 10 % 10 + '0';  // 年份十位
 824   4                      line2[6] = year % 10 + '0';       // 年份个位
 825   4                      line2[7] = '-';
 826   4                      line2[8] = month / 10 + '0'; // 月份十位
 827   4                      line2[9] = month % 10 + '0'; // 月份个位
 828   4                      line2[10] = '-';
 829   4                      line2[11] = day / 10 + '0'; // 日期十位
 830   4                      line2[12] = day % 10 + '0'; // 日期个位
 831   4      
 832   4                      LCD12864_DisplayOneLine(LINE2, line2, 16);
 833   4                  }
 834   3              }
 835   2          }
 836   1      
 837   1          if (buttonDown == 1)
 838   1          {
 839   2              Check();
 840   2          }
 841   1      
 842   1          if (shortOrLang == 1)
 843   1          {
 844   2              ShortPress();
 845   2          }
 846   1          else if (shortOrLang == 2)
 847   1          {
 848   2              LongPress();
 849   2          }
 850   1      
 851   1          if (mode == SHOW && alarm == 1)
 852   1          {
 853   2              if (hour == alarmHour && minute == alarmMinute && second == 00 && (alarmWeekday & (1 << weekday)) 
             -> 0 && interruptCount == 0)
 854   2                  alarmClockTimes = 2 * ALARMCLOCKTIMES;
 855   2              if (alarmClockTimes != 0)
 856   2              {
 857   3                  if ((0 < interruptCount && interruptCount < (250 / INTERVAL)) || ((500 / INTERVAL) < interrupt
C51 COMPILER V9.01   CLOCK                                                                 09/21/2023 20:59:27 PAGE 15  

             -Count && interruptCount < (750 / INTERVAL)))
 858   3                      Chime = !Chime;
 859   3                  else
 860   3                      Chime = 0;
 861   3                  if (interruptCount % (250 / INTERVAL) == 0)
 862   3                  {
 863   4                      alarmClockTimes--;
 864   4                      Chime = 0;
 865   4                  }
 866   3              }
 867   2          }
 868   1      
 869   1          if (mode == SHOW && hourlyChime == 1 && minute == 0 && second < 3)
 870   1          {
 871   2              if (hourlyChimeTimes == 0 && minute == 0 && second == 0 && interruptCount == 0)
 872   2                  hourlyChimeTimes = 2 * (HOURLYCHIMETIMES + 1); // 我也不知道这里为什么要加一，但事实就是它会响
             -HOURLYCHIMETIMES-1次，所以要加一补上。
 873   2              if (hourlyChimeTimes != 0)
 874   2              {
 875   3                  if (interruptCount > (500 / INTERVAL))
 876   3                      Chime = !Chime;
 877   3                  else
 878   3                      Chime = 0;
 879   3                  if (interruptCount % (500 / INTERVAL) == 0)
 880   3                  {
 881   4                      hourlyChimeTimes--;
 882   4                      Chime = 0;
 883   4                  }
 884   3              }
 885   2          }
 886   1      
 887   1          switch (mode)
 888   1          {
 889   2          case SET_HOUR:
 890   2              if (interruptCount < (500 / INTERVAL))
 891   2              {
 892   3                  line1[4] = setHour / 10 + '0';
 893   3                  line1[5] = setHour % 10 + '0';
 894   3              }
 895   2              else
 896   2              {
 897   3                  line1[4] = ' ';
 898   3                  line1[5] = ' ';
 899   3              }
 900   2              LCD12864_DisplayOneLine(LINE1, line1, 16);
 901   2              break;
 902   2          case SET_MINUTE:
 903   2              if (interruptCount < (500 / INTERVAL))
 904   2              {
 905   3                  line1[7] = setMinute / 10 + '0';
 906   3                  line1[8] = setMinute % 10 + '0';
 907   3              }
 908   2              else
 909   2              {
 910   3                  line1[7] = ' ';
 911   3                  line1[8] = ' ';
 912   3              }
 913   2              LCD12864_DisplayOneLine(LINE1, line1, 16);
 914   2              break;
 915   2          case SET_SECOND:
 916   2              if (interruptCount < (500 / INTERVAL))
 917   2              {
C51 COMPILER V9.01   CLOCK                                                                 09/21/2023 20:59:27 PAGE 16  

 918   3                  line1[10] = setSecond / 10 + '0';
 919   3                  line1[11] = setSecond % 10 + '0';
 920   3              }
 921   2              else
 922   2              {
 923   3                  line1[10] = ' ';
 924   3                  line1[11] = ' ';
 925   3              }
 926   2              LCD12864_DisplayOneLine(LINE1, line1, 16);
 927   2              break;
 928   2          case SET_YEAR:
 929   2              if (interruptCount < (500 / INTERVAL))
 930   2              {
 931   3                  line2[3] = year / 1000 + '0';     // 年份千位
 932   3                  line2[4] = year / 100 % 10 + '0'; // 年份百位
 933   3                  line2[5] = year / 10 % 10 + '0';  // 年份十位
 934   3                  line2[6] = year % 10 + '0';       // 年份个位
 935   3              }
 936   2              else
 937   2              {
 938   3                  line2[3] = ' ';
 939   3                  line2[4] = ' ';
 940   3                  line2[5] = ' ';
 941   3                  line2[6] = ' ';
 942   3              }
 943   2              LCD12864_DisplayOneLine(LINE2, line2, 16);
 944   2              break;
 945   2          case SET_MONTH:
 946   2              if (interruptCount < (500 / INTERVAL))
 947   2              {
 948   3                  line2[8] = month / 10 + '0'; // 月份十位
 949   3                  line2[9] = month % 10 + '0'; // 月份个位
 950   3              }
 951   2              else
 952   2              {
 953   3                  line2[8] = ' ';
 954   3                  line2[9] = ' ';
 955   3              }
 956   2              LCD12864_DisplayOneLine(LINE2, line2, 16);
 957   2              break;
 958   2          case SET_DAY:
 959   2              if (interruptCount < (500 / INTERVAL))
 960   2              {
 961   3                  line2[11] = day / 10 + '0'; // 日期十位
 962   3                  line2[12] = day % 10 + '0'; // 日期个位
 963   3              }
 964   2              else
 965   2              {
 966   3                  line2[11] = ' ';
 967   3                  line2[12] = ' ';
 968   3              }
 969   2              LCD12864_DisplayOneLine(LINE2, line2, 16);
 970   2              break;
 971   2          case STOPWATCH_START:
 972   2              stopwatchMSecond += INTERVAL;
 973   2              if (stopwatchMSecond > 999)
 974   2              {
 975   3                  stopwatchMSecond = 0;
 976   3                  stopwatchSecond++;
 977   3              }
 978   2              if (stopwatchSecond > 59)
 979   2              {
C51 COMPILER V9.01   CLOCK                                                                 09/21/2023 20:59:27 PAGE 17  

 980   3                  stopwatchSecond = 0;
 981   3                  stopwatchMinute++;
 982   3              }
 983   2              if (stopwatchMinute > 59)
 984   2              {
 985   3                  stopwatchMinute = 0;
 986   3              }
 987   2              line1[4] = stopwatchMinute / 10 + '0'; // 分钟十位
 988   2              line1[5] = stopwatchMinute % 10 + '0'; // 分钟个位
 989   2              line1[6] = ':';
 990   2              line1[7] = stopwatchSecond / 10 + '0'; // 秒十位
 991   2              line1[8] = stopwatchSecond % 10 + '0'; // 秒个位
 992   2              line1[9] = ':';
 993   2              line1[10] = stopwatchMSecond / 100 + '0';     // 毫秒百位
 994   2              line1[11] = stopwatchMSecond / 10 % 10 + '0'; // 毫秒十位
 995   2      
 996   2              LCD12864_DisplayOneLine(LINE1, line1, 16);
 997   2      
 998   2              break;
 999   2          case ALARMCLOCK:
1000   2      
1001   2              break;
1002   2          case ALARMCLOCK_HOUR:
1003   2      
1004   2              break;
1005   2          case ALARMCLOCK_MINUTE:
1006   2      
1007   2              break;
1008   2          case ALARMCLOCK_SUNDAY:
1009   2      
1010   2              break;
1011   2          case ALARMCLOCK_MONDAY:
1012   2      
1013   2              break;
1014   2          case ALARMCLOCK_TUESDAY:
1015   2      
1016   2              break;
1017   2          case ALARMCLOCK_WEDNESDAY:
1018   2      
1019   2              break;
1020   2          case ALARMCLOCK_THURSDAY:
1021   2      
1022   2              break;
1023   2          case ALARMCLOCK_FRIDAY:
1024   2      
1025   2              break;
1026   2          case ALARMCLOCK_SATURDAY:
1027   2      
1028   2              break;
1029   2          default:
1030   2              break;
1031   2          }
1032   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4442    ----
   CONSTANT SIZE    =     64    ----
   XDATA SIZE       =     14    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     85       3
   IDATA SIZE       =   ----    ----
C51 COMPILER V9.01   CLOCK                                                                 09/21/2023 20:59:27 PAGE 18  

   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
